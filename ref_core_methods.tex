\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}


\makeindex

\newcommand{\coderef}[2]{%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}

\begin{document}

\subsection{Core Methods}

\coderef{function Expression:evaluate()}{return Expression}
\index{Core!Methods!\texttt{evaluate}}

Applies to an expression that represents an operation on expressions to its subexpressions. For instance, evaluating a {\ttfamily DerivativeExpression} applies the derivative operator with respect to the {\ttfamily symbol} field to its {\ttfamily expression} field. Evaluating a {\ttfamily BinaryOperation} with its {\ttfamily operation} field set to {\ttfamily ADD} returns the sum of the numbers in the {\ttfamily expressions} field, if all of the expressions are numbers. If the expression does not represent an operation or is unable to be evaluated, calling {\ttfamily evaluate()} on an expression returns itself.

For example, the code:
\begin{minted}{latex}
\directlua{
    x = Integer(1)/Integer(2)
    y = Integer(2)/Integer(3)
    z = BinaryOperation(BinaryOperation.ADD,{x,y})
}
\[ \print{z} = \print{z:evaluate()}.\] 
\end{minted}
produces:
\directlua{
    x = Integer(1)/Integer(2)
    y = Integer(2)/Integer(3)
    z = BinaryOperation(BinaryOperation.ADD,{x,y})
}
\[ \print{z} = \print{z:evaluate()}.\]   

\coderef{function Expression:autosimplify()}{return Expression}
\index{Core!Methods!\texttt{autosimplify}}

Performs fast simplification techniques on an expression. Generally, one should call {\ttfamily autosimplify()} on expressions before applying other core methods to them. The {\ttfamily autosimplify()} method also calls the {\ttfamily evaluate()} method.

Consider the code:

\begin{minted}{latex}
\begin{CAS}
    vars('x','y','z')
    w = x/y + y/z + z/x 
\end{CAS}
\[ \print{w} = \print{w:autosimplify()} \]
\end{minted}
\begin{CAS}
    vars('x','y','z')
    w = x/y + y/z + z/x 
\end{CAS}
The output is as follows:
\[ \print{w} = \print{w:autosimplify()} \]
It seems that \texttt{autosimplify()} did nothing; but there are significant structural differences between \texttt{w} and \texttt{w:autosimplify()}:

\begin{multicols}{2}
    \begin{center}
        \underline{Expression tree for \texttt{w}}

    \parseforest{w}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {font = \ttfamily}
        @\forestresult
    \end{forest}

    \underline{Expression tree for \texttt{w:autosimplify()}}

    \parseforest{w:autosimplify()}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {font = \ttfamily}
        @\forestresult
    \end{forest}
\end{center}
\end{multicols}

Ironically, the \emph{autosimplified} expression tree on the right looks more complicated than the one on the left! But the main purpose of \texttt{autosimplify()} is to take an expression (that truly could be input in a myriad of ways) and convert that expression into something \emph{anticipatable}. 

For example, suppose the user inputs:
\begin{minted}{latex}
\begin{CAS}
    w = x/y + (z/x+y/z)
\end{CAS}
\end{minted}
In this case, the expression trees for \texttt{w} and \texttt{w:autosimplify()} look as follows:

\begin{multicols}{2}
\begin{center}
    \underline{Expression tree for \texttt{w}}

\parseforest{w}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\underline{Expression tree for \texttt{w:autosimplify}}

\parseforest{w:autosimplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}
\end{center}
\end{multicols}
{\bf Note:} \texttt{w:autosimplify()} is exactly the same as it was before despite the different starting point. This is an essential function of \texttt{autosimplify()}.

\coderef{function Expression:simplify()}{return Expression}
\index{Core!Methods!\texttt{simplify}}

Performs more extensive simplification of an expression. This may be slow, so this function is separate from autosimplification and is not called unless the user specifically directs the CAS to do so. The method aims to find an expression tree equivalent to the one given that is ``smaller'' in size as measured by the number of nodes in the expression tree. 

The \texttt{simplify()} method does call the \texttt{autosimplify()} method first. Here's an example of where the results of \texttt{autosimplify()} and \texttt{simplify()} differ:

\begin{minted}[breaklines]{latex}
\begin{CAS}
    vars('x')
    a = 1-x+0*x
    b = 1+1*x
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:autosimplify()} = \print{c:simplify()}. \]
\end{minted}
The code above produces:
\begin{CAS}
    vars('x')
    a = 1-x+0*x
    b = 1+1*x
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:autosimplify()} = \print{c:simplify()}. \] 
And here are the corresponding expression trees:
\begin{multicols}{2}
\begin{center}
    \underline{Expression tree for \texttt{c:autosimplify()}}

\parseforest{c:autosimplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\underline{Expression tree for \texttt{c:simplify()}}
    
\parseforest{c:simplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}
\end{center}
\end{multicols}

\coderef{function Expression:subexpressions()}{return table<number, Expression>}
\index{Core!Methods!\texttt{subexpressions}}

Returns a list of all subexpressions of an expression. This gives a unified interface to the instance variables for subexpressions, which have different names across classes.

For example, consider:
\begin{minted}{latex}
\begin{CAS}
    vars('x','y','z')
    a = x*y+y*z
    b = int(sin(x),x,0,pi/2)
\end{CAS}
\[ a = \print{a} \qquad \text{and} \qquad b=\print{b}.\] 
\end{minted}
This code produces:
\begin{CAS}
    vars('x','y','z')
    a = x*y+y*z
    b = int(sin(x),x,0,pi)
\end{CAS}
\[ a = \print{a} \qquad \text{and} \qquad b=\print{b}.\] 
Here are the expression shrubs for \texttt{a} and \texttt{b}:

\begin{multicols}{2}
\begin{center}
    \underline{Expression shrub for \texttt{a}}

    \parseshrub{a}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {draw,
            rectangle,
            rounded corners=1pt,
            fill=gray!10,
            s sep = 2cm,
            font=\ttfamily}
        @\shrubresult
    \end{forest}

    \underline{Expression shrub for \texttt{b}}

\parseshrub{b}
\bracketset{action character = @}
\begin{forest}
    for tree = {draw,
        rectangle,
        rounded corners=1pt,
        fill=gray!10,
        s sep = 1cm,
        font=\ttfamily}
    @\shrubresult
\end{forest}
\end{center}
\end{multicols}
On the other hand:
\begin{codebox}
\begin{minted}[breaklines,fontsize=\small]{lua}
for _,expr in ipairs(a:subexpressions()) do 
    tex.print("$", expr:tolatex(), "$\\quad")
end
\end{minted}
\tcblower
\luaexec{
    for _,expr in ipairs(a:subexpressions()) do 
        tex.print("$", expr:tolatex(), "$\\quad")
    end
}
\end{codebox}
while:
\begin{codebox}
\begin{minted}[breaklines,fontsize=\small]{lua}
for _,expr in ipairs(b:subexpressions()) do 
    tex.print("$", expr:tolatex(), "$\\quad")
end
\end{minted}
\tcblower
\luaexec{
    for _,expr in ipairs(b:subexpressions()) do 
        tex.print("$",expr:tolatex(),"$\\quad")
    end
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:size()}{return Integer}
\index{Core!Methods!\texttt{size}}

Returns the number of nodes of the tree that constitutes an expression, or roughly the total number of expression objects that make up the expression.

For example, consider:
\begin{minted}{latex}
\begin{CAS}
    vars('x')
    a = (1-x+0*x)
    b = (1+1*x)
    c = a*b
\end{CAS}
\end{minted}
\begin{CAS}
    vars('x')
    a = (1-x+0*x)
    b = (1+1*x)
    c = a*b
\end{CAS}
Then the expression trees for \texttt{c}, \texttt{c:autosimplify()}, and \texttt{c:simplify()} are as follows:

\begin{multicols}{3}
    \begin{center}
        \underline{Tree for \texttt{c}:}
\parseforest{c}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\columnbreak

\underline{Tree for \texttt{c:autosimplify()}:}
\parseforest{c:autosimplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\columnbreak

\underline{Tree for \texttt{c:simplify()}:}
\parseforest{c:simplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}
\end{center}
\end{multicols}
Accordingly, we have:
\begin{codebox}
    \begin{minted}[breaklines,fontsize=\scriptsize]{lua}
tex.print("The size of \\texttt{c} is",
  tostring(c:size()),"\\newline")
tex.print("The size of \\texttt{c:autosimplify()} is",
  tostring(c:autosimplify():size()), "\\newline")
tex.print("The size of \\texttt{c:simplify()} is",
  tostring(c:simplify():size()))
    \end{minted}
    \tcblower
    \luaexec{
    tex.print("The size of \\texttt{c} is", tostring(c:size()),"\\newline")
    tex.print("The size of \\texttt{c:autosimplify()} is", tostring(c:autosimplify():size()), "\\newline")
    tex.print("The size of \\texttt{c:simplfy()} is", tostring(c:simplify():size()))
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:setsubexpressions(subexpressions)}{return Expression}
\index{Core!Methods!\texttt{setsubexpressions}}

Creates a copy of an expression with the list of subexpressions as its new subexpressions. This can reduce code duplication in other methods.

\coderef{function Expression:freeof(symbol)}{return bool}
\index{Core!Methods!\texttt{freeof}}

Determines whether or not an expression contains a particular {\ttfamily SymbolExpression} somewhere in the tree.

The method \texttt{freeof()} is quite literal. For example:
\begin{codebox}
\begin{minted}[fontsize=\footnotesize]{lua}
x = SymbolExpression("foo")
y = SymbolExpression("bar")
z = x+y
if z:freeof(x) then 
    tex.print("I'm free!")
else 
    tex.print("I'm bound.")
end
\end{minted}
\tcblower
\directlua{
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    z = x+y
    if z:freeof(x) then 
        tex.print("I'm free!")
    else 
        tex.print("I'm bound.")
    end
}
\end{codebox}
On the other hand, the expression tree for \mintinline{lua}{SymbolExpression("foo")} contains a single node with no edges. With nary a \mintinline{lua}{SymbolExpression("fo")} to find in such a tree, we have:
\begin{codebox}
    \begin{minted}[fontsize=\footnotesize]{lua}
x = SymbolExpression("foo")
y = SymbolExpression("fo")
if x:freeof(y) then 
    tex.print("I'm free!")
else 
    tex.print("I'm bound.")
end
    \end{minted}
    \tcblower
    \directlua{
    x = SymbolExpression("foo")
    y = SymbolExpression("fo")
    if x:freeof(y) then 
        tex.print("I'm free!")
    else 
        tex.print("I'm bound.")
    end
}
    \end{codebox}

\coderef{function Expression:substitute(map)}{return Expression}
\index{Core!Methods!\texttt{substitute}}

Takes a table mapping expressions to other expressions and recursively maps each instance of an expression with its corresponding table expression.

\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    w = SymbolExpression("baz")
    z = (x/y):substitute({[y]=w,[x]=y})
\end{CAS}
\[ \print{z} \] 
\end{minted}
\tcblower
\begin{CAS}
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    w = SymbolExpression("baz")
    z = (x/y):substitute({[y]=w,[x]=y})
\end{CAS}
\[ \print{z} \] 
\end{codebox}

\coderef{function Expression:expand()}{return Expression}
\index{Core!Methods!\texttt{expand}}

Expands an expression, turning products of sums into sums of products.

\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x','y','z','w')
    a = x+y
    b = z+w
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:expand()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y','z','w')
    a = x+y
    b = z+w
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:expand()} \] 
\end{codebox}

\coderef{function Expression:factor()}{return Expression}
\index{Core!Methods!\texttt{factor}}

Factors an expression, turning sums of products into products of sums. For general \texttt{Expressions} this functionality is somewhat limited. For example:
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x')
    a = x-1
    b = a*x+a
\end{CAS}
\[ \print{b} = \print{b:factor()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y')
    a = x-y
    b = a*x+a*y
\end{CAS}
\[ \print{b} = \print{b:factor()} \] 
\end{codebox}
On the other hand:
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x','y')
    a = x^2-y^2
\end{CAS}
\[ \print{a} = \print{a:factor()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y')
    a = x^2-y^2
\end{CAS}
\[ \print{a} = \print{a:factor()} \] 
\end{codebox}


\coderef{function Expression:isatomic()}{return bool}
\index{Core!Methods!\texttt{isatomic}}

Determines whether an expression is \emph{atomic}, i.e., whether it has any subexpression fields. Otherwise, an expression is \emph{compound}. Atomic expressions and compound expressions are both sub-interfaces to expressions, and all classes inherit from one of those interfaces.

\begin{codebox}
    \begin{minted}[fontsize=\small]{lua}
x = SymbolExpression("x")
y = x*x+x
if x:isatomic() then 
    tex.print("I'm atomic.")
end 
if not y:isatomic() then 
    tex.print("But I'm compound.")
end
\end{minted}
\tcblower
\directlua{
    x = SymbolExpression("x")
    y = x*x+x
    if x:isatomic() then 
        tex.print("I'm atomic.")
    end 
    if not y:isatomic() then 
        tex.print("But I'm compound.")
    end
}
\end{codebox}
Since \texttt{SymbolExpression} inherits from \texttt{AtomicExpression}, we have that \texttt{isatomic()} is taken literally as well. For example:
\begin{codebox}
    \begin{minted}[fontsize=\small]{lua}
y = SymbolExpression("x*x+x")
if not y:isatomic() then 
    tex.print("But I'm compound.")
else
    tex.print("But I'm atomic!")
end
\end{minted}
\tcblower
\directlua{
    y = SymbolExpression("x*x+x")
    if not y:isatomic() then 
        tex.print("But I'm compound.")
    else
        tex.print("But I'm atomic!")
    end
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:isconstant()}{return bool}
\index{Core!Methods!\texttt{isconstant}}

Determines whether an expression is atomic and contains no variables. This method is counterintuitive in some cases. For instance:

\begin{codebox}
    \begin{minted}{lua}
if not pi:isconstant() then 
  tex.print("$\\pi$ is not constant.")
end  
\end{minted}
\tcblower
\luaexec{
if not pi:isconstant() then 
  tex.print("$\\pi$ is not constant.")
end  
}
\end{codebox}
This is because {\ttfamily isconstant()} is meant to check for certain autosimplification  transformations that can be performed on arbitrary {\ttfamily Ring} elements but not on those constants. Use {\ttfamily isrealconstant()} for what mathematicians think of as constants.

\coderef{function Expression:isrealconstant()}{return bool}
\index{Core!Methods!\texttt{isrealconstant}}

Determines whether an expression is a real number in the mathematical sense, such as $2$, $\sqrt{5}$, or $\sin(3)$. For example:

\begin{codebox}
    \begin{minted}{lua}
if pi:isrealconstant() then 
  tex.print("$\\pi$ is a real constant.")
end
\end{minted}
\tcblower
\luaexec{
    if pi:isrealconstant() then 
        tex.print("$\\pi$ is a real constant.")
    end
}
\end{codebox}

\coderef{function Expression:iscomplexconstant()}{return bool}
\index{Core!Methods!\texttt{iscomplexconstant}}

Determines whether an expression is a complex number in the mathematical sense, such as $3 + \sqrt{2}i$. It's helpful to keep in mind that, oftentimes, content needs to be simplified/evaluated in order to obtain the intended results:

\begin{codebox}[]
    \begin{minted}{lua}
a = (Integer.one() + I) ^ Integer(2)
if a:iscomplexconstant() then 
    tex.print("$",a:tolatex(),"$ is a complex constant.")
else 
    tex.print("$",a:tolatex(),"$ is not a complex constant.")
end
\end{minted}
\tcblower
\begin{center}
\luaexec{
    a =  (Integer.one() + I) ^ Integer(2)
    if a:iscomplexconstant() then 
        tex.print("$",a:tolatex(),"$ is a complex constant.")
    else 
        tex.print("$",a:tolatex(),"$ is not a complex constant.")
    end
}
\end{center}
\end{codebox}
While:
\begin{codebox}[]
    \begin{minted}{lua}
a = (Integer.one()+I) ^ Integer(2)
a = a:expand():simplify()
if a:iscomplexconstant() then 
    tex.print("$",a:tolatex(),"$ is a complex constant.")
else 
    tex.print("$",a:tolatex(),"$ is not a complex constant.")
end
\end{minted}
\tcblower
\begin{center}
\luaexec{
    a = (Integer.one()+I) ^ Integer(2)
    a = a:expand():simplify()
    if a:iscomplexconstant() then 
        tex.print("$",a:tolatex(),"$ is a complex constant.")
    else 
        tex.print("$",a:tolatex(),"$ is not a complex constant.")
    end
}
\end{center}
\end{codebox}

\coderef{function Expression:tolatex()}{return string}
\index{Core!Methods!\texttt{tolatex}}

Converts an expression to \LaTeX{} code. Some folks have strong feelings about how certain things are typeset. Case and point, which of these is your favorite:
\[ \int \sin(\frac{y}{2})dy \qquad \int \sin\left( \frac{y}{2} \right)dy \qquad \int \sin\left( \frac{y}{2} \right)\, dy \qquad \int \sin\!\left( \frac{y}{2} \right)\, dy \qquad \int \sin\!\left( \frac{y}{2} \right) \mathop{\mathrm{d}y} \qquad \int \sin\mathopen{}\left( \frac{y}{2} \right) \mathop{dy} \quad ?\]
We've tried to remain neutral:

\begin{codebox}
\begin{minted}{latex}
\begin{CAS}
    vars('y')
    f = diff(int(sin(y/2),y),y)
\end{CAS}
\[ \print{f} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('y')
    f = diff(int(sin(y/2),y),y)
\end{CAS}
\[ \print{f} \] 
\end{codebox} 
With any luck, we've pleased at least as many people as we've offended. In desperate times, one could rewrite the \texttt{tolatex()} method for any given class. Here, for example, is the \texttt{tolatex()} method as written for the \texttt{DerivativeExpression} class:
\begin{minted}[breaklines]{lua}
function DerivativeExpression:tolatex()
    return '\\frac{d}{d' .. self.symbol:tolatex() .. '}\\left(' .. self.expression:tolatex() .. '\\right)'
end
\end{minted} 
But there are heathens that live among us who might prefer:
\begin{minted}[breaklines]{lua}
function DerivativeExpression:tolatex()
    return '\\frac{\\mathrm{d}}{\\mathrm{d}' .. self.symbol:tolatex() .. '}\\left(' .. self.expression:tolatex() .. '\\right)'
end
\end{minted}
If we include the above function in a separate file, say \texttt{mytex.lua}, and use:

\mintinline{latex}{\directlua{dofile('mytex.lua')}}

or simply include the above function directly into the document via \mintinline{latex}{\directlua} or \mintinline{latex}{\luaexec}, then we would get:
\begin{codebox}
\begin{minted}{latex}
\begin{CAS}
  f = DerivativeExpression(y+sin(y),y)
\end{CAS}
\[ \print{f} \] 
\end{minted}
\tcblower 
\[ \frac{\mathrm{d}}{\mathrm{d}y} \left( y + \sin\mathopen{}\left(y\right) \right).\] 
\end{codebox}

\end{document}