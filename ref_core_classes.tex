\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}

\makeindex

\def\currref{Core Methods}

\newcommand{\coderef}[2]{%
\index{\currref!\texttt{#1}}%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\index{\currref!\texttt{#1}}%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}

\begin{document}

\subsection{Core Classes}

There are several classes in the core module; but only some classes are callable:

\begin{multicols}{2}
    \begin{center}
        \underline{Non-callable classes:}
    \begin{itemize}
        \item \texttt{Expression}
        \item \texttt{AtomicExpression}
        \item \texttt{ConstantExpression}
        \item \texttt{CompoundExpression}
    \end{itemize}

        \underline{Callable classes:}
    \begin{itemize}
        \item \texttt{SymbolExpression}
        \item \texttt{BinaryOperation}
        \item \texttt{FunctionExpression}
    \end{itemize}
\end{center}
\end{multicols}

\coderef{function SymbolExpression:new(string)}{return SymbolExpression} 

Creates a new \texttt{SymbolExpression}. For example:
\begin{codebox}[]
\begin{minted}[breaklines]{lua}
foo = SymbolExpression("bar")
tex.print("The Lua variable ``foo'' is the SymbolExpression:", foo:tolatex())
\end{minted}
\tcblower
\directlua{
foo = SymbolExpression("bar")
tex.print("The Lua variable 'foo' is the SymbolExpression", foo:tolatex())
}
\end{codebox}

\subsubsection{Parsing}

The command \mintinline{lua}{vars()} in \texttt{test.parser} creates a new \texttt{SymbolExpression} for every string in the argument; each such \texttt{SymbolExpression} is assigned to a variable of the same name. For example:

\begin{minted}{lua}
vars('x','y')
\end{minted}

is equivalent to:

\begin{minted}{lua}
x = SymbolExpression("x")
y = SymbolExpression("y")
\end{minted}

\newcoderef{function BinaryOperation:new(operation, expressions)}{return BinaryOperation}{operation function, expressions table<number,Expression>}

Creates a new \texttt{BinaryOperation}. For example:

\begin{codebox}
\begin{minted}{lua}
vars('x','y','z')
w = BinaryOperation(
    BinaryOperation.ADD,
    {BinaryOperation(
        BinaryOperation.MUL,
        {x,y}
    ),y,z}
)
tex.print("\\[w=",w:tolatex(),"\\]")
\end{minted}
\tcblower
\directlua{
vars('x','y','z')
w = BinaryOperation(
    BinaryOperation.ADD,
    {BinaryOperation(
        BinaryOperation.MUL,
        {x,y}
    ),y,z}
)
tex.print("\\[w=",w:tolatex(),"\\]")
}
\end{codebox}
The instance variable \texttt{operation} must be a function \mintinline{lua}{function f(a,b)} assigned to one of the following types:
\begin{itemize}
    \item \texttt{BinaryOperation.ADD}: \mintinline{lua}{return a + b}
    \item \texttt{BinaryOperation.SUB}: \mintinline{lua}{return a - b}
    \item \texttt{BinaryOperation.MUL}: \mintinline{lua}{return a * b}
    \item \texttt{BinaryOperation.DIV}: \mintinline{lua}{return a / b}
    \item \texttt{BinaryOperation.IDIV}: \mintinline{lua}{return a // b}
    \item \texttt{BinaryOperation.MOD}: \mintinline{lua}{return a % b}
    \item \texttt{BinaryOperation.POW}: \mintinline{lua}{return a ^ b}
\end{itemize}
The instance variable \texttt{expressions} must be a table of \texttt{Expression}s.

\subsubsection{Parsing}

Thank goodness for this. Creating new \texttt{BinaryOperation}s isn't nearly as cumbersome as the above would indicate. Using Lua's powerful metamethods, we can parse expressions much more easily. For example, the construction of \texttt{w} given above can be done much more naturally using:
\begin{codebox}
\begin{minted}{lua}
vars('x','y','z')
w = x*y+y+z
tex.print("\\[w=", w:tolatex(), "\\]")
\end{minted}
\tcblower
\directlua{
    vars('x','y','z')
    w = x*y+y+z
    tex.print("\\[w=", w:tolatex(), "\\]")
}
\end{codebox}

{\bf Warning:} there are escape issues to be aware of with the operator \mintinline{latex}{%}. If you're writing custom \texttt{luacas} functions in a separate \texttt{.lua} file, then there are no issues; use \mintinline{latex}{%} with reckless abandon. But when using the operator \mintinline{latex}{%} within, say \mintinline{latex}{\begin{CAS}..\end{CAS}}, then one should write \mintinline{latex}{\%} in place of \mintinline{latex}{%}:

\begin{codebox}[]
\begin{minted}{latex}
\begin{CAS}
    a = 17
    b = 5
    c = a \% b
\end{CAS}
\[ \print{c} \equiv \print{a} \bmod{\print{b}} \]
\end{minted}
\tcblower
\begin{CAS}
    a = 17
    b = 5
    c = a \% b
\end{CAS}
\[ \print{c} \equiv \print{a} \bmod{\print{b}} \] 
\end{codebox}
The above escape will {\bf not} work with \mintinline{latex}{\directlua}, but it will work for \mintinline{latex}{\luaexec} from the \texttt{luacode} package. Indeed, the \texttt{luacode} package was designed to make escapes like this more manageable. Here is the equivalent code using \mintinline{latex}{\luaexec}:
\begin{codebox}[]
\begin{minted}{latex}
\luaexec{
a = Integer(17)
b = Integer(5)
c = a \% b
tex.print("\\[",c:tolatex(),"\\equiv",a:tolatex(), "\\bmod{",b:tolatex(),"} \\]")
}
\end{minted}
\tcblower
\luaexec{
a = Integer(17)
b = Integer(5)
c = a \% b
tex.print("\\[", c:tolatex(), "\\equiv", a:tolatex(), "\\bmod{", b:tolatex(), "} \\]")
}
\end{codebox}

\newcoderef{function FunctionExpression:new(name,expressions)}{return FunctionExpression}{name string|SymbolExpression, expressions table<number,Expression>}

Creates a generic function. For example:
\begin{CAS}
    vars('x','f')
    g = f(x^2)
    g = diff(g,{x,2})
\end{CAS}
\[ \print*{g} \] 
\begin{CAS}
    vars('x','f','h')
    g = f(h(x))
    g = diff(g,x)
\end{CAS}
 \[ \print*{g} \] 
 \begin{CAS}
    vars('t')
    g = f(3*t,t^2)
    g = diff(g,t)
 \end{CAS}
 \[ \print*{g} \qquad \text{this is wrong}\] 


\end{document}