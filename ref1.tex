\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize
}

\makeindex

\def\currref{Core Methods}

\newcommand{\coderef}[1]{%
\index{\currref!\texttt{#1}}%
\begin{codehead}%
    \mintinline{lua}{#1}%
\end{codehead}%
}

\begin{document}

\subsection{Core Methods}

\coderef{function Expression:evaluate()}
Applies to an expression that represents an operation on expressions to its subexpressions. For instance, evaluating a {\ttfamily DerivativeExpression} applies the derivative operator with respect to the {\ttfamily symbol} field to its {\ttfamily expression} field. Evaluating a {\ttfamily BinaryOperation} with its {\ttfamily operation} field set to {\ttfamily ADD} returns the sum of the numbers in the {\ttfamily expressions} field, if all of the expressions are numbers. If the expression does not represent an operation or is unable to be evaluated, calling {\ttfamily evaluate()} on an expression returns itself.

For example, the code:
\begin{minted}{latex}
\directlua{
    x = Integer(1)/Integer(2)
    y = Integer(2)/Integer(3)
    z = BinaryOperation(BinaryOperation.ADD,{x,y})
}
\[ \print{z} = \print{z:evaluate()}.\] 
\end{minted}
produces:
\directlua{
    x = Integer(1)/Integer(2)
    y = Integer(2)/Integer(3)
    z = BinaryOperation(BinaryOperation.ADD,{x,y})
}
\[ \print{z} = \print{z:evaluate()}.\]   

\coderef{function Expression:autosimplify()}

Performs fast simplification techniques on an expression. Generally, one should call {\ttfamily autosimplify()} on expressions before applying other core methods to them. The {\ttfamily autosimplify()} method also calls the {\ttfamily evaluate()} method.

Consider the code:

\begin{minted}{latex}
\begin{CAS}
    vars('x','y','z')
    w = x/y + y/z + z/x 
\end{CAS}
\[ \print{w} = \print{w:autosimplify()} \]
\end{minted}
\begin{CAS}
    vars('x','y','z')
    w = x/y + y/z + z/x 
\end{CAS}
The output is as follows:
\[ \print{w} = \print{w:autosimplify()} \]
It seems that \texttt{autosimplify()} did nothing; but there are significant structural differences between \texttt{w} and \texttt{w:autosimplify()}:

\begin{multicols}{2}
    \begin{center}
        \underline{Expression tree for \texttt{w}}

    \parseforest{w}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {font = \ttfamily}
        @\forestresult
    \end{forest}

    \underline{Expression tree for \texttt{w:autosimplify()}}

    \parseforest{w:autosimplify()}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {font = \ttfamily}
        @\forestresult
    \end{forest}
\end{center}
\end{multicols}

Ironically, the \emph{autosimplified} expression tree on the right looks more complicated than the one on the left! But the main purpose of \texttt{autosimplify()} is to take an expression (that truly could be input in a myriad of ways) and convert that expression into something \emph{anticipatable}. 

For example, suppose the user inputs:
\begin{minted}{latex}
\begin{CAS}
    w = x/y + (z/x+y/z)
\end{CAS}
\end{minted}
In this case, the expression trees for \texttt{w} and \texttt{w:autosimplify()} look as follows:

\begin{multicols}{2}
\begin{center}
    \underline{Expression tree for \texttt{w}}

\parseforest{w}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\underline{Expression tree for \texttt{w:autosimplify}}

\parseforest{w:autosimplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}
\end{center}
\end{multicols}
{\bf Note:} \texttt{w:autosimplify()} is exactly the same as it was before despite the different starting point. This is an essential function of \texttt{autosimplify()}.

\coderef{function Expression:simplify()}

Performs more extensive simplification of an expression. This may be slow, so this function is separate from autosimplification and is not called unless the user specifically directs the CAS to do so. The method aims to find an expression tree equivalent to the one given that is ``smaller'' in size as measured by the number of nodes in the expression tree. 

The \texttt{simplify()} method does call the \texttt{autosimplify()} method first. Here's an example of where the results of \texttt{autosimplify()} and \texttt{simplify()} differ:

\begin{minted}[breaklines]{latex}
\begin{CAS}
    vars('x')
    a = 1-x+0*x
    b = 1+1*x
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:autosimplify()} = \print{c:simplify()}. \]
\end{minted}
The code above produces:
\begin{CAS}
    vars('x')
    a = 1-x+0*x
    b = 1+1*x
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:autosimplify()} = \print{c:simplify()}. \] 
And here are the corresponding expression trees:
\begin{multicols}{2}
\begin{center}
    \underline{Expression tree for \texttt{c:autosimplify()}}

\parseforest{c:autosimplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}

\underline{Expression tree for \texttt{c:simplify()}}
    
\parseforest{c:simplify()}
\bracketset{action character = @}
\begin{forest}
    for tree = {font = \ttfamily}
    @\forestresult
\end{forest}
\end{center}
\end{multicols}

\coderef{function Expression:subexpressions()}

Returns a list of all subexpressions of an expression. This gives a unified interface to the instance variables for subexpressions, which have different names across classes.

For example, consider:
\begin{minted}{latex}
\begin{CAS}
    vars('x','y','z')
    a = x*y+y*z
    b = int(sin(x),x,0,pi/2)
\end{CAS}
\[ a = \print{a} \qquad \text{and} \qquad b=\print{b}.\] 
\end{minted}
This code produces:
\begin{CAS}
    vars('x','y','z')
    a = x*y+y*z
    b = int(sin(x),x,0,pi)
\end{CAS}
\[ a = \print{a} \qquad \text{and} \qquad b=\print{b}.\] 
Here are the expression shrubs for \texttt{a} and \texttt{b}:

\begin{multicols}{2}
\begin{center}
    \underline{Expression shrub for \texttt{a}}

    \parseshrub{a}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {draw,
            rectangle,
            rounded corners=1pt,
            fill=gray!10,
            s sep = 2cm,
            font=\ttfamily}
        @\shrubresult
    \end{forest}

    \underline{Expression shrub for \texttt{b}}

\parseshrub{b}
\bracketset{action character = @}
\begin{forest}
    for tree = {draw,
        rectangle,
        rounded corners=1pt,
        fill=gray!10,
        s sep = 1cm,
        font=\ttfamily}
    @\shrubresult
\end{forest}
\end{center}
\end{multicols}
On the other hand:
\begin{codebox}
\begin{minted}[breaklines,fontsize=\small]{lua}
for _,expr in ipairs(a:subexpressions()) do 
    tex.print("$", expr:tolatex(), "$\\quad")
end
\end{minted}
\tcblower
\luaexec{
    for _,expr in ipairs(a:subexpressions()) do 
        tex.print("$", expr:tolatex(), "$\\quad")
    end
}
\end{codebox}
while:
\begin{codebox}
\begin{minted}[breaklines,fontsize=\small]{lua}
for _,expr in ipairs(b:subexpressions()) do 
    tex.print("$", expr:tolatex(), "$\\quad")
end
\end{minted}
\tcblower
\luaexec{
    for _,expr in ipairs(b:subexpressions()) do 
        tex.print("$",expr:tolatex(),"$\\quad")
    end
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:size()}

Returns the number of nodes of the tree that constitutes an expression, or roughly the total number of expression objects that make up the expression.

For example, consider:
\begin{minted}{latex}
\begin{CAS}
    vars('x')
    a = (1-x+0*x)
    b = (1+1*x)
    c = a*b
\end{CAS}
\end{minted}
\begin{CAS}
    vars('x')
    a = (1-x+0*x)
    b = (1+1*x)
    c = a*b
\end{CAS}
Then:
\begin{codebox}
    \begin{minted}[breaklines,fontsize=\footnotesize]{lua}
tex.print("The size of \\texttt{c} is",
  tostring(c:size()),"\\newline")
tex.print("The size of \\texttt{c:autosimpliy()} is",
  tostring(c:autosimplify():size()), "\\newline")
tex.print("The size of \\texttt{c:simplfy()} is",
  tostring(c:simplify():size()))
    \end{minted}
    \tcblower
    \luaexec{
    tex.print("The size of \\texttt{c} is", tostring(c:size()),"\\newline")
    tex.print("The size of \\texttt{c:autosimpliy()} is", tostring(c:autosimplify():size()), "\\newline")
    tex.print("The size of \\texttt{c:simplfy()} is", tostring(c:simplify():size()))
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:setsubexpressions(subexpressions)}

Creates a copy of an expression with the list of subexpressions as its new subexpressions. This can reduce code duplication in other methods.

\coderef{function Expression:freeof(symbol)}

Determines whether or not an expression contains a particular {\ttfamily SymbolExpression} somewhere in the tree.

The method \texttt{freeof()} is quite literal. For example:
\begin{codebox}
\begin{minted}[fontsize=\footnotesize]{lua}
x = SymbolExpression("foo")
y = SymbolExpression("bar")
z = x+y
if z:freeof(x) then 
    tex.print("I'm free!")
else 
    tex.print("I'm bound.")
end
\end{minted}
\tcblower
\directlua{
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    z = x+y
    if z:freeof(x) then 
        tex.print("I'm free!")
    else 
        tex.print("I'm bound.")
    end
}
\end{codebox}
On the other hand, the expression tree for \mintinline{lua}{SymbolExpression("foo")} contains a single node with no edges. With nary a \mintinline{lua}{SymbolExpression("fo")} to find in such a tree, we have:
\begin{codebox}
    \begin{minted}[fontsize=\footnotesize]{lua}
x = SymbolExpression("foo")
y = SymbolExpression("fo")
if x:freeof(y) then 
    tex.print("I'm free!")
else 
    tex.print("I'm bound.")
end
    \end{minted}
    \tcblower
    \directlua{
    x = SymbolExpression("foo")
    y = SymbolExpression("fo")
    if x:freeof(y) then 
        tex.print("I'm free!")
    else 
        tex.print("I'm bound.")
    end
}
    \end{codebox}

\coderef{function Expression:substitute(map)}

Takes a table mapping expressions to other expressions and recursively maps each instance of an expression with its corresponding table expression.

\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    w = SymbolExpression("baz")
    z = (x/y):substitute({[y]=w,[x]=y})
\end{CAS}
\[ \print{z} \] 
\end{minted}
\tcblower
\begin{CAS}
    x = SymbolExpression("foo")
    y = SymbolExpression("bar")
    w = SymbolExpression("baz")
    z = (x/y):substitute({[y]=w,[x]=y})
\end{CAS}
\[ \print{z} \] 
\end{codebox}

\coderef{function Expression:expand()}

Expands an expression, turning products of sums into sums of products.

\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x','y','z','w')
    a = x+y
    b = z+w
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:expand()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y','z','w')
    a = x+y
    b = z+w
    c = a*b
\end{CAS}
\[ \print{c} = \print{c:expand()} \] 
\end{codebox}

\coderef{function Expression:factor()}

Factors an expression, turning sums of products into products of sums. For general \texttt{Expressions} this functionality is somewhat limited. For example:
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x')
    a = x-1
    b = a*x+a
\end{CAS}
\[ \print{b} = \print{b:factor()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y')
    a = x-y
    b = a*x+a*y
\end{CAS}
\[ \print{b} = \print{b:factor()} \] 
\end{codebox}
On the other hand:
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    vars('x','y')
    a = x^2-y^2
\end{CAS}
\[ \print{a} = \print{a:factor()} \] 
\end{minted}
\tcblower
\begin{CAS}
    vars('x','y')
    a = x^2-y^2
\end{CAS}
\[ \print{a} = \print{a:factor()} \] 
\end{codebox}


\coderef{function Expression:isatomic()}

Determines whether an expression is \emph{atomic}, i.e., whether it has any subexpression fields. Otherwise, an expression is \emph{compound}. Atomic expressions and compound expressions are both sub-interfaces to expressions, and all classes inherit from one of those interfaces.

\begin{codebox}
    \begin{minted}[fontsize=\small]{lua}
x = SymbolExpression("x")
y = x*x+x
if x:isatomic() then 
    tex.print("I'm atomic.")
end 
if not y:isatomic() then 
    tex.print("But I'm compound.")
end
\end{minted}
\tcblower
\directlua{
    x = SymbolExpression("x")
    y = x*x+x
    if x:isatomic() then 
        tex.print("I'm atomic.")
    end 
    if not y:isatomic() then 
        tex.print("But I'm compound.")
    end
}
\end{codebox}
Since \texttt{SymbolExpression} inherits from \texttt{AtomicExpression}, we have that \texttt{isatomic()} is taken literally as well. For example:
\begin{codebox}
    \begin{minted}[fontsize=\small]{lua}
y = SymbolExpression("x*x+x")
if not y:isatomic() then 
    tex.print("But I'm compound.")
else
    tex.print("But I'm atomic!")
end
\end{minted}
\tcblower
\directlua{
    y = SymbolExpression("x*x+x")
    if not y:isatomic() then 
        tex.print("But I'm compound.")
    else
        tex.print("But I'm atomic!")
    end
}
\end{codebox}
\vskip 0.2cm

\coderef{function Expression:isconstant()}

Determines whether an expression is atomic and contains no variables. This method is counterintuitive in some cases, for instance, it returns {\ttfamily false} for the constant $\pi$. This is because {\ttfamily isconstant()} is meant to check for certain autosimplification  transformations that can be performed on arbitrary {\ttfamily Ring} elements but not on those constants. Use {\ttfamily isrealconstant()} for what mathematicians think of as constants.

\coderef{function Expression:isrealconstant()}

Determines whether an expression is a real number in the mathematical sense, such as $2$, $\sqrt{5}$, or $\sin(3)$.

\coderef{function Expression:iscomplexconstant()}

Determines whether an expression is a complex number in the mathematical sense, such as $3 + \sqrt{2}i$.

\coderef{function Expression:tolatex()}

Converts an expression to \LaTeX{} code.

\end{document}