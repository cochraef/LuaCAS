\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse}
\usepackage{microtype}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\begin{document}

\subsection{Tutorial 3: Adding Functionality}

Charlie is, like Alice and Bob, also teaching calculus. Charlie likes Alice's examples and wants to try something similar. But Charlie would like to do more involved examples using rational functions. Accordingly, Charlie copy-n-pastes Alice's code:
\begin{CAS}
    vars('x','h')
    f = 1/(x^2+1)
    subs = {[x]=x+h}
    q = (substitute(subs,f)-f)/h
    q = expand(q)
\end{CAS}
\begin{minted}{latex}
\begin{CAS}
    vars('x','h')
    f = 1/(x^2+1)
    subs = {[x]=x+h}
    q = (substitute(subs,f)-f)/h
    q = expand(q)
\end{CAS}
\end{minted}
Unfortunately, \mintinline{latex}{\[ q=\print{q} \]} produces:
\[ q = \print{q} \]
The \mintinline{lua}{simplify()} command doesn't seem to help either! What Charlie truly needs is to combine terms, i.e., Charlie needs to find a \emph{common denominator}. They're horrified to learn that no such functionality exists in this burgeoning package. 

So what's Charlie to do? They could put in a feature request, but they're concerned that the schlubs in charge of managing the package won't get around to it until who-knows-when. So Charlie decides to take matters into their own hands. Besides, looking for that silver lining, they'll learn a little bit about how \texttt{luacas} is structured. 

At the heart of any CAS are \texttt{Expressions}. Mathematically speaking, an \texttt{Expression} is a rooted tree. Luckily, this tree can be drawn using the (wonderful) \texttt{forest} package. In particular, the command \mintinline{latex}{\parseforest{q}} will scan the contents of the expression \texttt{q} and parse the results into a form compatible with the \texttt{forest} package; those results are saved in a macro named \mintinline{latex}{\forestresult}. 

\tcbsidebyside[ 
    sidebyside adapt=right,
    enhanced,skin=bicolor,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
    ]{
    \inputminted[ 
        firstline = 17,
        lastline = 29,
        breaklines
    ]
    {latex}
    {demotut3.tex}}
    {\parseforest{q}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {
            font=\ttfamily,
            rectangle,
            rounded corners=1pt
        },
        where level=0{%
            fill=orange!25
        }{},
        @\forestresult
    \end{forest}}
The root of the tree above is \texttt{ADD} since $q$ is, at its heart, the addition of two other expressions. Charlie wonders how they might check to see if a mystery \texttt{Expression} is an \texttt{ADD}? But this is putting the cart before the horse; Charlie should truly wonder how to check for the \emph{type} of \texttt{Expression} -- then they can worry about other attributes. 

Charlie can print the \texttt{Expression} type directly into his document using the \mintinline{latex}{\whatis} command:

\begin{codebox}
    \inputminted[ 
        firstline = 31,
        lastline = 34,
        breaklines
    ]
    {latex}
    {demotut3.tex}
    \tcblower
    \begin{CAS}
        r = diff(q,x,x)
    \end{CAS}
    \whatis{q} vs \whatis{r}
\end{codebox}

So \texttt{q} is a \texttt{BinaryOperation}? This strikes Charlie as a little strange. On the other hand, \texttt{q} is the result of a binary operation applied to two other expressions; so perhaps this makes a modicum of sense. 

At any rate, Charlie now knows, according to \texttt{luacas}, that \texttt{q} is of the \texttt{Expression}-type \whatis{q}. The actual operator that's used to form \texttt{q} is stored in the attribute \mintinline{lua}{q.operation}:

\tcbsidebyside[ 
    sidebyside adapt=right,
    enhanced,skin=bicolor,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
    ]{
    \inputminted[ 
        firstline = 36,
        lastline = 38,
        breaklines
    ]
    {latex}
    {demotut3.tex}}
    {
    \luaexec{
    if q.operation == BinaryOperation.ADD then 
        tex.sprint("I'm an \\texttt{ADD}")
    end
    }}

Of course, different \texttt{Expression} types have different attributes. For example, being a \texttt{DiffExpression}, \texttt{r} has the attribute \texttt{r.degree}:

\tcbsidebyside[ 
    sidebyside adapt=right,
    enhanced,skin=bicolor,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
    ]{
    \inputminted[ 
        firstline = 40,
        lastline = 40,
        breaklines
    ]
    {latex}
    {demotut3.tex}}
    {
    \luaexec{
        tex.print("I'm an order", r.degree, "derivative.")
    }}

\texttt{BinaryOperation}s have several attributes, but the most important attribute for Charlie's purposes is \texttt{q.expressions}. In this case, \texttt{q.expressions} is a table with two entries; those two entries are precisely the \texttt{Expressions} whose sum forms \texttt{q}. In particular, 

\mintinline{latex}{\[ \print{q.expressions[1]} \qquad \text{and} \qquad \print{q.expressions[2]} \]}

produces:
\[ \print{q.expressions[1]} \qquad\text{and} \qquad \print{q.expressions[2]} \] 

The expression \texttt{q.expressions[1]} is another \texttt{BinaryOperation}. Instead of printing the entire expression tree (as we've done above), Charlie might be interested in the commands \mintinline{latex}{\parseshrub} and \mintinline{latex}{\shrubresult}:

\tcbsidebyside[ 
    sidebyside adapt=right,
    enhanced,skin=bicolor,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
    ]{\small
    \inputminted[ 
        firstline = 48,
        lastline = 54,
        breaklines
    ]
    {latex}
    {demotut3.tex}}
    {\parseshrub{q.expressions[1]}
     \bracketset{action character = @}
        \begin{forest}
            for tree = {draw,rectangle,rounded corners=1pt,fill=lightgray!20,font=\ttfamily, s sep=1.5cm}
            @\shrubresult
    \end{forest}
}

The ``shrub'' is essentially the first level of the ``forest'', but with some extra information concerning attributes. For contrast, here's the result of \mintinline{latex}{\parseshrub} and \mintinline{latex}{\shrubresult} applied to \texttt{r}, the \texttt{DiffExpression} defined above. 

\tcbsidebyside[ 
    sidebyside adapt=right,
    enhanced,skin=bicolor,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
    ]{\small
    \inputminted[ 
        firstline = 56,
        lastline = 62,
        breaklines
    ]
    {latex}
    {demotut3.tex}}
    {\parseshrub{r}
    \bracketset{action character = @}
    \begin{forest}
        for tree = {draw,rectangle,rounded corners=1pt,
            fill=lightgray!20,font=\ttfamily, s sep=1.5cm}
        @\shrubresult
    \end{forest}
}
The attribute \mintinline{lua}{r.degree} returns the size of the table stored in \mintinline{lua}{r.symbols} which, in turn, records the variables (and order) with which to differentiate the expression stored in \mintinline{lua}{r.expression}.

Now that Charlie knows the basics of how \texttt{luacas} is structured, they're ready to 


\end{document}


write their own function \texttt{combine} that will take a sum of rational expressions and form an equivalent singular rational expression under a common denominator. Charlie will need to know a little Lua, but nothing too far beyond the typical \texttt{if-then} logical operators. 

It's best if Charlie writes this Lua function in a separate file, say \texttt{myfunction.lua}. We walk through Charlie's design below, and like many functions in \texttt{luacas}, he defines this function as a method:

\begin{minted}[breaklines,linenos]{lua}
function Expression:combine()
    local den, num, aux, input = {}, {}, {}, self:simplify()
    if input.operation ~= BinaryOperation.ADD then 
        return input
    end
\end{minted}

First, Charlie checks if the input, renamed and simplified from \mintinline{lua}{self} to \mintinline{lua}{input}, is in fact a \texttt{BinaryOperation} with operation equal to \texttt{ADD}. If not, then \texttt{input} is returned.

\begin{minted}[breaklines,linenos,firstnumber=6]{lua}
    for _, expr in ipairs(input.expressions) do
\end{minted}

Next, Charlie starts to march through the expressions \texttt{expr} of \texttt{result} stored in \texttt{result.expressions}. 

\begin{minted}[breaklines,linenos,firstnumber=7]{lua}
        local numpart, denpart = Integer.one(), Integer.one()
            if expr.operation == BinaryOperation.POW and expr.expressions[2] == -Integer.one() then 
\end{minted}
The first thing Charlie checks is if the current \texttt{expr} is a \texttt{BinaryOperation} with operation \texttt{POW}. If so, then Charlie checks to see if the second expression in \texttt{expr} is equal to $-1$ (if \texttt{expr} is a \texttt{POW}, then the exponent is stored in \texttt{expr.expressions[2]}). If so, then this means that \texttt{expr.expressions[1]} is a denominator-term.

\begin{minted}[breaklines,linenos,firstnumber=9]{lua}
                denpart = denpart*expr.expressions[1]
                for _,term in ipairs(den) do 
                    if expr.expressions[1] == term then 
                        goto continue
                    end
                end
                table.insert(den,expr.expressions[1])
                ::continue::
            end
\end{minted}

In this case, Charlie makes \texttt{expr.expressions[1]} a factor of the local variable \texttt{denpart} (for \emph{denominator part}). Charlie then scans the contents of the table \texttt{den} to see if \texttt{expr.expressions[1]} has already been included. If it hasn't, then Charlie includes it into the table with \texttt{table.insert}. The table \texttt{den} will eventually contain all terms that comprise the common denominator. Of course, \texttt{expr} may not be a \texttt{POW}...

\begin{minted}[linenos,breaklines,firstnumber=18]{lua}
        if expr.operation == BinaryOperation.MUL then 
            for _,subexpr in ipairs(expr.expressions) do 
                if subexpr.operation == BinaryOperation.POW and subexpr.expressions[2] == -Integer.one() then
                    denpart = denpart*subexpr.expressions[1]    
                    for _,term in ipairs(den) do 
                        if subexpr.expressions[1] == term then 
                            goto continue
                        end
                    end
                    table.insert(den,subexpr.expressions[1])
                    ::continue::
                else 
                    numpart = numpart*subexpr 
                end
            end
        end
        if not (expr.operation == BinaryOperation.POW or expr.operation == BinaryOperation.MUL) then 
            numpart = expr 
        end
        table.insert(num,numpart)
        table.insert(aux,denpart)
    end
\end{minted}
In particular, it could be that \texttt{expr} is a \texttt{MUL}, or  neither a \texttt{POW} nor a \texttt{MUL}. So Charlie must reckon with these possibilities as well. But in all cases, Charlie marches through the (sub)expressions, recording denominators and numerators as they go. In the end, Charlie has:
\begin{itemize}
    \item \texttt{den}, a table whose product of terms gives us the common denominator we seek;
    \item \texttt{num}, a table whose terms are the numerators of the subexpressions of the parent \texttt{ADD} expression;
    \item \texttt{aux}, a table whose terms are the denominators of the subexpressions of the parent \texttt{ADD} expression.
\end{itemize}
Charlie now forms the \texttt{denominator} of the final output.
\begin{minted}[breaklines,linenos,firstnumber=40]{lua}
    local denominator = Integer.one()
    local numerator   = Integer.zero()
    for _,expr in ipairs(den) do 
        denominator = denominator*expr
    end
    denominator = denominator:autosimplify()
\end{minted}
Charlie now forms the \texttt{numerator} of the final output.
\begin{minted}[breaklines,linenos,firstnumber=46]{lua}
    for index,expr in ipairs(num) do
        local uncommon = denominator/aux[index]
        uncommon = uncommon:factor():simplify()
        numerator = numerator + expr*uncommon
    end
    numerator = numerator:simplify()
\end{minted}
Finally, Charlie returns the final result:
\begin{minted}[breaklines,linenos,firstnumber=52]{lua}
    return numerator/denominator
end
\end{minted}
Charlie may now use the \texttt{:combine()} method within \mintinline{latex}{\begin{CAS}..\end{CAS}}. 
