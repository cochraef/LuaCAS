\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse,documentation}
\usepackage{microtype}
\usepackage{makeidx}
\usepackage{fontawesome5}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\DeclareTotalTCBox{\lilcoderef}{O{} m m}{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    enhanced,
    nobeforeafter,
    tcbox raise base,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=1mm,
    right=1mm,
    top=1mm,
    bottom=1mm,
    oversize,
    #1
}{\mintinline{lua}{#2} \mintinline{lua}{#3}}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}

\makeindex

\newcommand{\coderef}[2]{%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}
\usepackage{marginnote}

\begin{document}
\setdescription{style=multiline,
        topsep=10pt,
        leftmargin=6.5cm,
        }

\subsection{Algebra Methods}

Many classes in the algebra package inherit from the {\ttfamily Ring} interface, which itself inherits from the \\ {\ttfamily ConstantExpression} interface. The {\ttfamily Ring} interface requires the following arithmetic operations, which have corresponding abstract metamethods listed below. The abstract methods get passed to concrete methods in the concrete classes that inherit from {\ttfamily Ring} in the obvious way.

For {\ttfamily Ring} objects {\ttfamily a} and {\ttfamily b}:

\SetLabelAlign{parright}{\parbox[t]{\labelwidth}{\raggedleft#1}}
\begin{description}%[labelwidth = 6.5cm,align=parright]
    \item[\lilcoderef{function a:add(b)}{return (a + b)}] Adds two ring elements.
    \item[\lilcoderef{function a:sub(b)}{return (a - b)}] Subtracts one ring element from another. Subtraction has a default implementation in {\ttfamily Ring.lua} as adding the additive inverse, but this can be overwritten if a faster performance method is available.
    \item[\lilcoderef{function a:neg()}{return (-a)}] Returns the additive inverse of a ring element.
    \item[\lilcoderef{function a:mul(b)}{return (a * b)}] Multiplies two ring elements.
    \item[\lilcoderef{function a:pow(n)}{return (a ^ n)}] Raises one ring element to the power of an integer. Exponentiation has a default implementation as repeated multiplication, but this can (and probably should) be overwritten for faster performance.
    \item[\lilcoderef{function a:eq(b)}{return (a == b)}] Tests if two ring elements are the same.
    \item[\lilcoderef{function a:lt(b)}{return (a < b)}] Tests if one ring element is less than another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item[\lilcoderef{function a:le(b)}{return (a <= b)}] Tests if one ring element is less than or equal to another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item[\lilcoderef{function a:zero()}{return Ring}] Returns the additive identity of the ring to which \texttt{a} belongs.
    \item[\lilcoderef{function a:one()}{return Ring}] Returns the multiplicative identity of the ring to which \texttt{a} belongs.
\end{description}

\reversemarginpar
Arithmetic\marginnote{\color{rose}\large\faHandPointRight} of {\ttfamily Ring} elements will (generally) not form a {\ttfamily BinaryOperation}. Instead, the appropriate \mintinline{lua}{__RingOperation} is called which then passes the arithmetic to a specific ring, if possible. For example:
\begin{codebox}
    \begin{minted}[fontsize=\small]{latex}
\begin{CAS}
    f = Poly({2,1})
    g = Poly({2,5})
    h = f+g
\end{CAS}
\[ (\print{f}) + (\print{g}) = \print{h} \] 
\end{minted}
\tcblower
\begin{CAS}
    f = Poly({2,1})
    g = Poly({2,5})
    h = f+g
\end{CAS}
\[ (\print{f}) + (\print{g}) = \print{h} \] 
\end{codebox}
So why have the {\ttfamily Ring} class to begin with? Many of the rings in the algebra package are subsets of one another. For instance, integers are subsets of rationals, which are subsets of polynomial rings over the rationals, etc. To smoothly convert objects from one ring to another, it's good to have a class like {\ttfamily Ring} to handle all the ``traffic.'' 

For example, the {\ttfamily RingIdentifier} object acts as a pseudo-class that stores information about the exact ring of an object, including the symbol the ring has if it's a polynomial ring, for instance. To perform operations on two elements of different rings, the CAS does the following: 

To get the generic {\ttfamily RingIdentifier} from a class, it uses the static method:
\coderef{function Ring.makering()}{return RingIdentifier}

To get the {\ttfamily RingIdentifier} from a specific instance (element) of a ring, it uses the method:

\coderef{function Ring:getring()}{return RingIdentifier}

So, for example:

\begin{codebox}
    \begin{minted}{lua}
a = Integer(2)/Integer(3)
ring = a:getring()
if ring == Integer.makering() then
    tex.print('same')
else
    tex.print('different')
end
\end{minted}
\tcblower
\luaexec{
a = Integer(2)/Integer(3)
ring = a:getring()
if ring == Integer.makering() then
    tex.print('same rings')
else
    tex.print('different rings')
end
}
\end{codebox}

From there, the CAS computes the smallest {\ttfamily RingIdentifier} that contains the two {\ttfamily RingIdentifier}s as subsets using the static method:

\newcoderef{function Ring.resultantring(ring1,ring2)}{return RingIdentifier}{ring1 RingIdentifier, ring2 RingIdentifier}

So, for example:

\begin{codebox}
    \begin{minted}{lua}
a = Poly({Integer(2),Integer(1)})
b = Integer(3)
ring1 = a:getring()
ring2 = b:getring()
ring = Ring.resultantring(ring1,ring2)
if ring == a:getring() then 
    tex.print('polynomials')
end
\end{minted}
\tcblower
\luaexec{
    a = Poly({Integer(2),Integer(1)})
    b = Integer(3)
    ring1 = a:getring()
    ring2 = b:getring()
    ring = Ring.resultantring(ring1,ring2)
    if ring == a:getring() then 
        tex.print('polynomials')
    end
}
\end{codebox}

Finally, the CAS converts both objects into the resultant {\ttfamily RingIdentifier}, if possible,  using the method:

\coderef{function Ring:inring(ring)}{return Ring}

So, for example: 

\begin{codebox}
    \begin{minted}{lua}
b = b:inring(ring)
if b:type() == PolynomialRing then 
    tex.print('b is a polynomial now')
end
\end{minted}
\tcblower
\luaexec{
    b = b:inring(ring)
    if b:type() == PolynomialRing then 
        tex.print('b is a polynomial now')
    end
}
\end{codebox}

Finally, the CAS is able to perform the operation with the correct \mintinline{lua}{__RingOperation}. This all happens within the hierarchy of \texttt{Ring} classes automatically:
\begin{codebox}
    \begin{minted}{latex}
\begin{CAS}
    a = Poly({1/2,3,1})
    b = 1/2
    c = a+b
\end{CAS}
\[ \print{a} + \print{b} = \print{c} \] 
\end{minted}
\tcblower
\begin{CAS}
    a = Poly({1/2,3,1})
    b = 2/3
    c = a+b
\end{CAS}
\[ \print{a} + \print{b} = \print{c} \] 
\end{codebox}


To add another class that implements {\ttfamily Ring} and has proper conversion abilities, the {\ttfamily resultantring} method needs to be updated to include all possible resultant rings constructed from the new ring and existing rings. The other three methods need to be implemented as well.

\end{document}