\documentclass{article}

\usepackage{luacas}

\usepackage[margin=1.5in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{tikz}
\usepackage{minted}
%\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
\usepackage{microtype}


\newtcolorbox{codebox}{
    enhanced,skin=bicolor,
    sidebyside,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\begin{document}
\title{A portable Computer Algebra System capable of symbolic computation for use in Lua\LaTeX{}: \\  The {\ttfamily luacas} package }
\author{Evan Cochrane \\ {\itshape Timothy All, Joe Eichholz}}
\date{} 

\maketitle 

\tableofcontents

\section{Introduction}

The package {\ttfamily luacas} allows for symbolic computation within \LaTeX{}. For example:
\begin{CAS}
    vars('x','y')
    f = 3*x*y - x^2*y 
    fx = diff(f,x)
\end{CAS}
\inputminted[
firstline=7,
lastline=11,
breaklines]
{latex}
{docdemo.tex}
The above code will compute the partial derivative $f_x$ of the function $f$ defined by 
\[ f(x,y)=3xy-x^2y.\]
There are various methods for fetching and/or printing results from the CAS within your \LaTeX{} document:

\begin{codebox}
\inputminted[
firstline=14,
lastline=14,
breaklines]
{latex}
{docdemo.tex}
\tcblower
\[ \print*{fx} = \print{fx} \] 
\end{codebox}

\subsection{About}

The core CAS program is written purely in Lua and integrated into \LaTeX{} via Lua\LaTeX{}. Currently, most existing computer algebra systems such as Maple and Mathematica allow converting their stored expressions to \LaTeX{} code, but this still requires exporting code from \LaTeX{} to another program and importing it back, which can be tedious.

The target audience for this package are mathematics students, instructors, and professionals who would like some ability to perform basic symbolic computations within \LaTeX{} without the need for laborious and technical setup. But truly, this package was born out of a desire from the authors to learn more about symbolic computation. What you're looking at here is the proverbial ``carrot at the end of the stick'' to keep our learning moving forward.
                
Using a scripting language (like Lua) for the core CAS reduces performance dramatically, but the following considerations make it a good option for our intentions: 
                
\begin{itemize}
    \item Compiled languages that can communicate with \LaTeX{} in some way (such as C through Lua) require compiling the code on each machine before running, reducing portability.
    \item Our target usage would generally not involve computations that take longer than a second, such as factoring large primes or polynomials.
    \item Lua is a fast scripting language, especially when compared to Python, and is designed to be compact and portable.
    \item If C code could be used, we could tie into one of many open-source C symbolic calculators, but the point of this project is to learn the mathematics of symbolic computation. The barebones but friendly nature of Lua make it a fairly ideal language from a pedagogical point of view.
\end{itemize}

\subsection{Features}
                
Currently, {\ttfamily luacas} includes the following functionality:
                
\begin{itemize}
    \item Arbitrary-precision integer and rational arithmetic
    \item Number-theoretic algorithms for factoring integers and determining primality
    \item Constructors for arbitrary polynomial rings and integer mod rings, and arithmetic algorithms for both
    \item Factoring univariate polynomials over the rationals and over finite fields
    \item Polynomial decomposition and some multivariate functionality, such as pseudodivision
    \item Basic symbolic root finding
    \item Symbolic expression manipulations such as expansion, substitution, and simplification
    \item Symbolic differentiation and integration
\end{itemize}
                
The CAS is written using object-oriented Lua, so it is modular and would be easy to extend its functionality (which we hope to do in the future).

\section{Installation}

\subsection{Requirements}

The \texttt{luacas} package (naturally) requires you to compile with Lua\LaTeX{}. Beyond that, the following packages are required:
\begin{multicols}{2}
{\ttfamily 
\begin{itemize}
    \item xparse
    \item pgfkeys
    \item verbatim
    \item amsmath
    \item luacode
    \item iftex
    \item tikz/forest
    \item xcolor
\end{itemize}}
\end{multicols}
The packages {\ttfamily tikz, forest, xcolor} aren't strictly required, but they are needed for drawing expression trees.

\subsection{Installing {\ttfamily luacas}}
The package manager for your local TeX distribution ought to install the package fine on its own. But for those who like to take matters into their own hands: unpack \texttt{luacas.zip} in the current working directory (or in a directory visible to TeX, like your local texmf directory), and in the preamble of your document, put:
\inputminted[firstline=3,
    lastline=3,
    breaklines]
    {latex}
    {doc.tex}
That's it. 

\section{Tutorial}

\subsection{Beginner}

\subsection{Intermediate}

\subsection{Advanced}



\appendix

\section{The \LaTeX{} code}

As noted above, this package is really a Lua program; the package {\ttfamily luacas.sty} is merely a shell to make accessing that Lua program easy and manageable from within \LaTeX{}. 
\inputminted[
    firstline=12,
    lastline=14,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}

We check to make sure the user is compiling with Lua\LaTeX{}; if not, an error message is printed and compilation is aborted. 

\inputminted[
    firstline=16,
    lastline=24,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}

The following pacakages are required for various macros:

\inputminted[
    firstline=27,
    lastline=32,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}
    
\section{Lua Documentation}

This section assumes some familiarity with the programming language Lua. For a comprehensive introduction to Lua, we refer the reader to \cite{pil}.


This computer algebra system is written in object-oriented Lua. Lua, of course, does not have built-in object-oriented features, but using metatables we can simulate much of the oo functionality of a language like Java. Every class in the CAS inherits from the {\ttfamily Expression} interface. Expressions are really trees, and may have any number of sub-expressions as children depending on the type of the expression.

Most operations that a user would want to apply to expressions, such as derivatives and integrals, for instance, are encapsulated into their own classes that have the expressions that these operations are applied to as instance variables. The other kind of operations on expressions are \emph{core methods}, which are proper methods in the objected-oriented sense, and can be called on expressions using the {\ttfamily :} syntax as is typical in Lua. The rule of thumb is that if there is standard mathematical notation for an operation or function represented by the CAS, it gets its own class, and if not, it is a core method.


\subsection{Core Methods}

All of the following core methods can be applied to any expression, and are defined in the {\ttfamily expression.lua} interface.

\begin{itemize}
    \item {\ttfamily evaluate()} applies an expression that represents an operation on expressions to its subexpressions. For instance, evaluating a {\ttfamily DerrivativeExpression} applies the derivative operator with respect to the {\ttfamily symbol} field to its {\ttfamily expression} field. If the expression does not represent an operation or is unable to be evaluated, calling {\ttfamily evaluate()} on an expression returns itself.
    
    \item {\ttfamily autosimplify()} performs fast simplification techniques on an expression. All input from the \LaTeX{} end and everything output to the \LaTeX{} end is autosimplified. Generally, one should call {\ttfamily autosimplify()} on expressions before applying other core methods to them. The {\ttfamily autosimplify()} method also calls the {\ttfamily evaluate()} method.
    
    \item {\ttfamily subexpressions()} returns a list of all subexpressions of an expression. This gives a unified interface to the fields of objects, which have different names across classes.
    
    \item {\ttfamily setsubexpressions(subexpressions)} creates a copy of an expression with the list of subexpressions as its new subexpressions. This can reduce code duplication in other methods.
    
    \item {\ttfamily freeof(symbol)} determines whether or not an expression contains a particular \\ {\ttfamily SymbolExpression} somewhere in the tree.
    
    \item {\ttfamily substitute(map)} takes a table mapping expressions to other expressions and recursively maps each instance of an expression with its corresponding table expression.
    
    \item {\ttfamily expand()} expands an expression, turning sums of products into products of sums.
    
    \item {\ttfamily factor()} factors an expression, turning products of sums into sums of products.
    
    \item {\ttfamily isatomic()} determines whether an expression is \emph{atomic}, i.e., whether it has any subexpression fields.
    
    \item {\ttfamily isconstant()} determines whether an expression contains no variables.
    
    \item {\ttfamily tolatex()} converts an expression to \LaTeX{} code.
\end{itemize}

The number of core expressions should be kept small, since every new type of expression must implement all of these methods. 

\subsection{Algebra Package}

\subsection{Calculus Package}

\subsection{Basic Parsing}


\end{document}