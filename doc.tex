\documentclass{article}

\usepackage{standalone}
\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}

\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{positioning,calc}
\usepackage[edges]{forest}
\usepackage{minted}
\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
    \tcbuselibrary{xparse}
\usepackage{microtype}
\usepackage[toc]{multitoc}

\renewcommand{\comment}[1]{}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}

\definecolor{rose}{RGB}{128,0,0}
\definecolor{roseyellow}{RGB}{222,205,99}
\definecolor{roseblue}{RGB}{167,188,214}
\definecolor{rosenavy}{RGB}{79,117,139}
\definecolor{roseorange}{RGB}{232,119,34}
\definecolor{rosegreen}{RGB}{61,68,30}
\definecolor{rosewhite}{RGB}{223,209,167}
\definecolor{rosebrown}{RGB}{108,87,27}
\definecolor{rosegray}{RGB}{84,88,90}

\definecolor{codegreen}{HTML}{49BE25}

\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle,
    %frame hidden
}

\newtcolorbox{codehead}[1][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1
}

\usepackage{varwidth}

\newtcolorbox{newcodehead}[2][]{
    enhanced,
    frame hidden,
    colback=rosegray!15,
    boxrule=0mm,
    leftrule=5mm,
    rightrule=5mm,
    boxsep=0mm,
    arc=0mm,
    outer arc=0mm,
    left=3mm,
    right=3mm,
    top=1mm,
    bottom=1mm,
    toptitle=1mm,
    bottomtitle=1mm,
    oversize,
    #1,
    fonttitle=\bfseries\ttfamily\footnotesize,
    coltitle=rosegray,
    attach boxed title to top text right,
    boxed title style={frame hidden,size=small,bottom=-1mm,
    interior style={fill=none,
    top color=white,
    bottom color=white}},
    title={#2}
}
\usepackage{makeidx}
\makeindex

\newcommand{\coderef}[2]{%
\begin{codehead}[sidebyside,segmentation hidden]%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{codehead}%
}

\newcommand{\newcoderef}[3]{%
\begin{newcodehead}[sidebyside,segmentation hidden]{#3}%
    \mintinline{lua}{#1}%
    \tcblower%
    \begin{flushright}%
    \mintinline{lua}{#2}%
    \end{flushright}%
\end{newcodehead}%
}

\def\error{\color{red}}
\def\self{\color{gray}}
\def\call{$\star$ }

\begin{document}
\title{A portable Computer Algebra System capable of symbolic computation for use in Lua\LaTeX{}: \\  The {\ttfamily luacas} package }
\author{Evan Cochrane \\ {\itshape Timothy All}}
\date{} 

\maketitle 

\begin{abstract}
    Put abstract here. 
\end{abstract}

\tableofcontents

\include{intropart.tex}

\include{intro.tex}

\include{tut.tex}

\include{tut1.tex}

\include{tut2.tex}

\include{tut3.tex}

\include{ref.tex}

\include{ref_core.tex}

\include{ref_core_classes.tex} 

\include{ref_core_methods.tex} 

\include{ref_algebra.tex}

\include{ref_algebra_classes.tex}

\appendix

\include{latexcode.tex}

\comment{
\section{Lua Documentation}

This section is geared towards those who are interested in the inner workings of the Lua end of the CAS. In particular, anyone who wishes to modify or expand the CAS for their own purposes should read this.
 
This section also assumes some familiarity with the programming language Lua, including using prototypes for object-oriented programning in Lua. For a comprehensive introduction to Lua, we refer the reader to \cite{pil}. Chapter 16 of \cite{pil} provides a good introduction to object-oriented design and inheritance in Lua. 
 
 \subsection{Class Structure and Inheritance}
 
Every object in the CAS is an expression, meaning it inherits from the {\ttfamily Expression} type (class). Since the {\ttfamily Expression} type itself has no constructor and cannot be instantiated, it it closer to an interface in Java OOP terms.\footnote{In reality, interfaces are unnecessary in Lua due to its weak typing - Lua doesn't check whether an object has a method at compile time. The {\ttfamily Expression} type is really an abstract class in Java terms, but we will call it an interface for simplicity.} {\ttfamily Expression}s can store any number of other expressions as sub-expressions, depending on type. This means that {\ttfamily Expression} objects are really trees. Types that inherit from {\ttfamily Expression} that can not store other expressions are called \emph{atomic expressions}, and correspond to the leaf nodes of the tree. Other expression types are \emph{compound expressions}. Thus, every {\ttfamily Expression} type inherits from one of {\ttfamily AtomicExpression} or {\ttfamily CompoundExpression}. The {\ttfamily ConstantExpresssion} interface is a subinterface to {\ttfamily AtomicExpression}.\footnote{See the Section B.2. {\ttfamily isconstant()} entry for details.} Types that inherit from {\ttfamily ConstantExpression} roughly correspond to numbers. An outline of the inheritance hierarchy is pictured below:

\begin{figure}[h]
\centering

\begin{tikzpicture}[interface/.style={rectangle, draw=roseorange!60, fill=roseorange!5, very thick, minimum size=5mm,outer sep=3pt},class/.style={text width=2.5cm,rectangle, draw=rosenavy!60, fill=rosenavy!5, very thick, minimum size=5mm}]

\node[interface] at (0, 0) (exp) {\ttfamily Expression};
\node[interface] at (-2, -2) (atom) {\ttfamily AtomicExpression};
\node[interface] at (2, -2) (comp) {\ttfamily CompoundExpression};
\node[interface] at (-6, -4) (constant) {\ttfamily ConstantExpression};

\node[class] (num) [below=of constant] {Integers, Rationals};

\node[class] at (-2, -4) (sym) [below=of atom] {Symbols, Polynomials};

\node[class] at (2, -4) (sum) [below=of comp] {Sums, Products, \newline Integrals, Sets, Vectors, Matrices};

\draw[->,thick] (atom) edge (exp)
    (comp) edge (exp)
    (constant) edge (atom)
    (num) edge (constant)
    (sym) edge (atom)
    (sum) edge (comp);

\end{tikzpicture}

\caption{Interfaces in the Lua\LaTeX{} CAS and examples of types that inherit from each interface.}

\end{figure}

Most operations that a user would want to apply to expressions, such as derivatives and integrals, are encapsulated into their own types. These types have the {\ttfamily Expression}s that these operations are applied to as instance variables, and thus are compound expressions. The other kind of operations on expressions are \emph{core methods}, which are methods in the objected-oriented sense, and can be called on expressions using the {\ttfamily :} syntax as is typical in Lua. The rule of thumb is that if there is standard mathematical notation for an operation or function represented by the CAS, it gets its own class, and if not, it is a core method. This way, every Lua expression corresponds to something that can be cleanly displayed in \LaTeX{}. This also gives us a compact way to display expression trees in this guide, namely, using mathematical notation.


\subsubsection{Metamethod inheritance}
This CAS takes advantage of Lua's metamethods, particularly the mathematical operators, to reduce the notational burden of expression construction. Unlike regular methods, metamethods cannot be inherited - if two tables don't have a {\ttfamily \_\_add} metamethod, it won't trigger the table's {\ttfamily \_\_index} metamethod. This means that all such metamethods are created in their own tables with names that start with a double underscore, such as {\ttfamily \_\_RingOperations}, and assigned to the correct object in its constructor method.


\subsection{Core Methods}

All of the following core methods can be applied to any expression, and are defined in the {\ttfamily expression.lua} interface.

\begin{itemize}
    \item {\ttfamily evaluate()} applies an expression that represents an operation on expressions to its subexpressions. For instance, evaluating a {\ttfamily DerrivativeExpression} applies the derivative operator with respect to the {\ttfamily symbol} field to its {\ttfamily expression} field. Evaluating a {\ttfamily BinaryOperation} with its {\ttfamily operation} field set to {\ttfamily ADD} returns the sum of the numbers in the {\ttfamily expressions} field, if all of the expressions are numbers. If the expression does not represent an operation or is unable to be evaluated, calling {\ttfamily evaluate()} on an expression returns itself.
    
    \item {\ttfamily autosimplify()} performs fast simplification techniques on an expression. All input from the \LaTeX{} end and everything output to the \LaTeX{} end is autosimplified. Generally, one should call {\ttfamily autosimplify()} on expressions before applying other core methods to them. The {\ttfamily autosimplify()} method also calls the {\ttfamily evaluate()} method.
    
    \item {\ttfamily simplify()} performs full simplification of an expression. This may involve polynomial factorization, which is slow, so this is seperate from autosimplification and not called on the \LaTeX{} end unless the user specifically directs the CAS to simplify.
    
    \item {\ttfamily subexpressions()} returns a list of all subexpressions of an expression. This gives a unified interface to the instance variables for subexpressions, which have different names across classes.
    
    \item {\ttfamily size()} returns the number of nodes of the tree that constitutes an expression, or roughly the total number of expression objects that make up the expression.
    
    \item {\ttfamily setsubexpressions(subexpressions)} creates a copy of an expression with the list of subexpressions as its new subexpressions. This can reduce code duplication in other methods.
    
    \item {\ttfamily freeof(symbol)} determines whether or not an expression contains a particular \\ {\ttfamily SymbolExpression} somewhere in the tree.
    
    \item {\ttfamily substitute(map)} takes a table mapping expressions to other expressions and recursively maps each instance of an expression with its corresponding table expression.
    
    \item {\ttfamily expand()} expands an expression, turning sums of products into products of sums.
    
    \item {\ttfamily factor()} factors an expression, turning products of sums into sums of products.
    
    \item {\ttfamily isatomic()} determines whether an expression is \emph{atomic}, i.e., whether it has any subexpression fields. Otherwise, an expression is \emph{compound}. Atomic expressions and compound expressions are both sub-interfaces to expressions, and all classes inherit from one of those interfaces.
    
    \item {\ttfamily isconstant()} determines whether an expression is atomic and contains no variables. This method is counterintuitive in some cases, for instance, it returns {\ttfamily false} for the constant $\pi$. This is because {\ttfamily isconstant()} is meant to check for certain autosimplification  transformations that can be performed on arbitrary {\ttfamily Ring} elements but not on those constants. Use {\ttfamily isrealconstant()} for what mathematicians think of as constants.
    
    \item {\ttfamily isrealconstant()} determines whether an expression is a real number in the mathematical sense, such as $2$, $\sqrt{5}$, or $\sin(3)$.
    
    \item {\ttfamily iscomplexconstant()} determines whether an expression is a complex number in the mathematical sense, such as $3 + \sqrt{2}i$.
    
    \item {\ttfamily tolatex()} converts an expression to \LaTeX{} code.
\end{itemize}

The number of core methods should generally be kept small, since every new type of expression must implement all of these methods. The exception to this, of course, is core methods that call other core methods that provide a unified interface to expressions. For instance, {\ttfamily size()} calls {\ttfamily subexpressions()}, so it only needs to be implemented in the expression interface.

All expressions should also implement the {\ttfamily \_\_tostring} and {\ttfamily \_\_eq} metamethods. As mentioned previously, metamethods cannot be inherited using Lua, thus every expression object created by a constructor must assign a metatable to that object.

\begin{itemize}
    \item {\ttfamily \_\_tostring} provides a human-readable version of an expression for printing within Lua. Used for debugging purposes.
    
    \item {\ttfamily \_\_eq} determines whether an expression is structurally identical to another expression.
\end{itemize}

\subsection{Algebra Package}

The algebra package contains functionality for arbitrary-precision arithmetic, polynomial arithmetic and factoring, symbolic root finding, and logarithm and trigonometric expression classes. It requires the core package to be loaded.

\subsubsection{Ring Interfaces}

Most classes in the algebra package inherit from the {\ttfamily Ring} interface, which itself inherits from the \\ {\ttfamily ConstantExpression} interface. The {\ttfamily Ring} interface requires the following arithmetic operations, which have corresponding metamethods listed below. For ring objects {\ttfamily a} and {\ttfamily b},

\begin{itemize}
    \item {\ttfamily a:add(b) (a + b)} adds two ring elements.
    \item {\ttfamily a:sub(b) (a - b)} subtracts one ring element from another. Subtraction has a default implementation in {\ttfamily Ring.lua} as adding the additive inverse, but this can be overwritten if a faster performance method is available.
    \item {\ttfamily a:neg() (-a)} returns the additive inverse of a ring element.
    \item {\ttfamily a:mul(b) (a * b)} multiplies two ring elements.
    \item {\ttfamily a:pow(n) (a \wedge{} n)} raises one ring element to the power of an integer. Exponentiation has a default implementation as repeated multiplication, but this can (and probably should) be overwritten for faster performance.
    \item {\ttfamily a:eq(b) (a == b)} tests if two ring elements are the same.
    \item {\ttfamily a:lt(b) (a < b)} tests if one ring element is less than another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item {\ttfamily a:le(b) (a <= b)} tests if one ring element is less than or equal to another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item {\ttfamily a:zero()} returns the additive identity of a ring.
    \item {\ttfamily a:one()} returns the multiplicative identity of a ring.
\end{itemize}

The arithmetic methods should only be used with two objects of the same type, while the metamethods can be used on objects of potentially different types, since they handle conversion between different types of rings. \footnote{See section B.3.2 for details.}

The {\ttfamily EuclideanDomain} interface is a subinterface to the Ring interface, which also requires the following operations:

\begin{itemize}
    \item {\ttfamily a:divremainder(b) (a // b) (a \% b)} returns both the result of Eulcidean division and the remainder when a is divided by b.
\end{itemize}

The {\ttfamily Field} interface is a subinterface to the {\ttfamily EuclideanDomain} interface, which also requires the following operations:

\begin{itemize}
    \item {\ttfamily a:div(b) (a / b)} divides one ring element by another. Division has a default implementation as multiplying by the multiplicative inverse, but this can be overwritten if a faster performance method is available.
     \item {\ttfamily a:inv()} returns the multiplicative inverse of a ring element.
\end{itemize}


\subsubsection{Ring Conversion}

Many of the rings in the algebra package are subsets of one another. For instance, integers are subsets of rationals, which are subsets of polynomial rings over the rationals, etc. To smoothly convert objects from one ring to another, the {\ttfamily RingIdentifier} object acts as a pseudo-class that stores information the exact ring of an object, including the symbol the ring has if it's a polynomial ring, for instance. To perform operations on two elements of different rings, the CAS does the following: 

To get the generic {\ttfamily RingIdentifier} from a class, it uses the static {\ttfamily Ring.makering()} method. To get the {\ttfamily RingIdentifier} from a specific instance (element) of a ring, it uses the {\ttfamily :getring()} method. From there, the CAS computes the smallest {\ttfamily RingIdentifier} that contains the two {\ttfamily RingIdentifier}s as subsets using the static {\ttfamily Ring.resultantring()}. Finally, the CAS converts both objects into the resultant {\ttfamily RingIdentifier} using the {\ttfamily :inring(ring)} method if possible, and then performs the operation.

To add another class that implements {\ttfamily Ring} and has proper conversion abilities, the {\ttfamily resultantring} method needs to be updated to include all possible resultant rings constructed from the new ring and existing rings. The other three methods need to be implemented as well.

\subsubsection{Types}

The following types do not inherit from the {\ttfamily Ring} interface, instead inheriting from the {\ttfamily CompoundExpression} interface.

\begin{itemize}
    \item {\ttfamily AbsExpression(expression)} creates a new expression corresponding to the absolute value of \\ {\ttfamily expression}.
    \item {\ttfamily Logarithm(base, expression)} creates a new expression corresponding to the logarithm base {\ttfamily base} of {\ttfamily expression}.
    \item {\ttfamily FactorialExpression(expression)} creates a new expression corresonding to the factorial of {\ttfamily expression}.
    \item {\ttfamily SqrtExpression(expression, root)} creates a new expression corresponding the the {\ttfamily root}th root of {\ttfamily expression}. If {\ttfamily root} is omitted, it defaults to $2$.
    \item {\ttfamily TrigExpression(name, expression)} creates a new expression corresponding to a trigonometric function applied to {\ttfamily expression}. The valid names are $\sin$, $\cos$, $\tan$, $\csc$, $\sec$, $\cot$, $\arcsin$, $\arccos$, $\arctan$, arccsc, arcsec, and arccot.
    
    \item {\ttfamily RootExpression(expression)} creates an expression that represents the solutions to {\ttfamily expression} $= 0$ when they would be unwieldy or impossible to display using standard algebraic functions.
\end{itemize}


The following types inherit from the {\ttfamily Ring} interface. However, not all of them are proper {\ttfamily ConstantExpression}s, so some of them override the {\ttfamily isconstant()} method.

\begin{itemize}
    \item {\ttfamily Integer(n)} takes a string, number, or {\ttfamily Integer} input and constructs an Integer. Since Lua can only store integers exactly up to a certain point, it is recommended to use strings to build large integers.
    \item {\ttfamily IntegerModN(i, n)} takes an {\ttfamily Integer i} and {\ttfamily Integer n} and constructs an integer in the ring $\mathbb{Z_n}$. 
    \item {\ttfamily Rational(n, d, keep)} takes a numerator {\ttfamily n} and denominator {\ttfamily d} in the same ring and constructs a rational expression in the field of fractions over that ring. For the integers, this is the ring of rational numbers. If the {\ttfamily keep} flag is omitted, the constructed object will be simplified to have smallest possible denominator, possibly returning an object in the original ring {\ttfamily n} and {\ttfamily d} where in.
    \item {\ttfamily PolynomialRing(coefficients, symbol, degree)} takes a list of {\ttfamily coefficients} not necessarily in the same ring and a {\ttfamily SymbolExpression symbol} to create a polynomial in the polynomial ring with the given {\ttfamily symbol} and coefficients in the smallest possible ring that includes all of the coefficients. If {\ttfamily degree} is omitted, it will calculate the degree of the polynomial automatically. The list can either be one-indexed or zero-indexed, but if it is one-indexed, the internal list of coefficients will still be zero-indexed.
\end{itemize}

\subsection{Calculus Package}

The calculus package contains expression types for integration and differentiation. It requires both the algebra and core packages to be loaded.

\subsubsection{Types}
All types added by the calculus package inherit from the {\ttfamily CompoundExpression} interface.

\begin{itemize}
    \item {\ttfamily DerivativeExpression(expression, symbol)} creates a new derivative expression, representing the single-variable derivative of {\ttfamily expression} with respect to {\ttfamily symbol}. If {\ttfamily symbol} is omitted, it defaults to $x$.
    
    \item {\ttfamily DiffExpression(expression, symbols)} creates a new differential expression, representing the multi-variable derivative of {\ttfamily expression} with respect to each symbol in the list {\ttfamily symbol}.
    
    \item {\ttfamily IntegralExpression(expression, symbol, lower, upper)} creates a new indefinite integral expression, representing the integral of {\ttfamily expression} with respect to {\ttfamily symbol} from {\ttfamily lower} to {\ttfamily upper} If both {\ttfamily lower} and {\ttfamily upper} are omitted, creates a new indefinite integral expression instead.
\end{itemize}

\subsection{Constructing Expressions \& Basic Parsing}

Algebraic computations on the Lua end typically involve constructing the desired expression and applying one or more core operations to the expression. If a non-core operation is applied, then this core expression will be {\ttfamily autosimplify()}.

Naively, one could nest class constructors to build an expression. For instance, the Lua code for evaluating the integral \[ \int_0^6 \sin(x) + 2x^2 + 3 \hspace{2pt}\mathrm{d}x\] and storing the result in a variable {\ttfamily r} is as follows:

\begin{minted}{lua}
r = IntegralExpression(BinaryOperation(BinaryOperation.ADD,
            {TrigExpression("sin", SymbolExpression("x")),
            BinaryOperation(BinaryOperation.MUL,
                {Integer(2),
                BinaryOperation(BinaryOperation.POW,
                {SymbolExpression("x"), Integer(2)})}),
            Integer(3)}),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

This is more than unwieldy, so a number of constructs are added to make using and developing the CAS easier. Metatables for many binary operations allow natural symbols to act as constructors that use Lua's build-in operator precedence:

\begin{minted}{lua}
r = IntegralExpression(TrigExpression("sin", SymbolExpression("x")) +
        Integer(2) * SymbolExpression("x") ^ Integer(2) +
        Integer(3),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

Several functions are added as shorthand for constructors that mirror familiar syntax. These function names are in all caps to reduce the risk of collisions.

\begin{minted}{lua}
r = INT(SIN(SymbolExpression("x")) + Integer(2) * SymbolExpression("x") ^ Integer(2) 
    + Integer(3),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

This is still fairly unwieldy, mostly because every string and number need to be wrapped in a constructor to convert them to expressions. Unfortunately, this syntax is also the most awkward to avoid in Lua, and the inner workings of the code just uses the longer constructors.

For \LaTeX{} users, or for Lua users who are looking for a simpler paradigm, a parser was implemented that takes the code input as a string and wraps numbers in the {\ttfamily Integer} constructor, then evaluates the code using Lua's {\ttfamily load()} function. The {\ttfamily vars()} command also allows variables to be declared as symbol expressions with the same name, at the cost of being able to use these symbols to reference other objects. Using the parser, the code now looks like:

\begin{minted}{lua}
CASparse([[
    vars("x")
    r = int(sin(x) + 2*x^2 + 3, x, 0, 6)
]])
\end{minted}
}

\newpage

\printindex


\end{document}