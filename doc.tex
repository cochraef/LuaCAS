\documentclass{article}

\usepackage{luacas}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[margin=1in]{geometry}
\usepackage[shortlabels]{enumitem}


\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{minted}
%\usemintedstyle{pastie}
\usepackage[hidelinks]{hyperref}
\usepackage{parskip}
\usepackage{multicol}
\usepackage[most]{tcolorbox}
\usepackage{microtype}

\usepackage[
backend=biber,
style=numeric,
]{biblatex}
\addbibresource{sources.bib}


\newtcolorbox{codebox}[1][sidebyside]{
    enhanced,skin=bicolor,
    #1,
    arc=1pt,
    colframe=brown,
    colback=brown!15,colbacklower=white,
    boxrule=1pt,
    notitle
}

\begin{document}
\title{A portable Computer Algebra System capable of symbolic computation for use in Lua\LaTeX{}: \\  The {\ttfamily luacas} package }
\author{Evan Cochrane \\ {\itshape Timothy All, Joe Eichholz}}
\date{} 

\maketitle 

\tableofcontents

\section{Introduction}

The package {\ttfamily luacas} allows for symbolic computation within \LaTeX{}. For example:
\begin{CAS}
    vars('x','y')
    f = 3*x*y - x^2*y 
    fx = diff(f,x)
\end{CAS}
\inputminted[
firstline=7,
lastline=11,
breaklines]
{latex}
{docdemo.tex}
The above code will compute the partial derivative $f_x$ of the function $f$ defined by 
\[ f(x,y)=3xy-x^2y.\]
There are various methods for fetching and/or printing results from the CAS within your \LaTeX{} document:

\begin{codebox}
\inputminted[
firstline=14,
lastline=14,
breaklines]
{latex}
{docdemo.tex}
\tcblower
\[ \print*{fx} = \print{fx} \] 
\end{codebox}

\subsection{About}

The core CAS program is written purely in Lua and integrated into \LaTeX{} via Lua\LaTeX{}. Currently, most existing computer algebra systems such as Maple and Mathematica allow converting their stored expressions to \LaTeX{} code, but this still requires exporting code from \LaTeX{} to another program and importing it back, which can be tedious.

The target audience for this package are mathematics students, instructors, and professionals who would like some ability to perform basic symbolic computations within \LaTeX{} without the need for laborious and technical setup. But truly, this package was born out of a desire from the authors to learn more about symbolic computation. What you're looking at here is the proverbial ``carrot at the end of the stick'' to keep our learning moving forward.
                
Using a scripting language (like Lua) for the core CAS reduces performance dramatically, but the following considerations make it a good option for our intentions: 
                
\begin{itemize}
    \item Compiled languages that can communicate with \LaTeX{} in some way (such as C through Lua) require compiling the code on each machine before running, reducing portability.
    \item Our target usage would generally not involve computations that take longer than a second, such as factoring large primes or polynomials.
    \item Lua is a fast scripting language, especially when compared to Python, and is designed to be compact and portable.
    \item If C code could be used, we could tie into one of many open-source C symbolic calculators, but the point of this project is to learn the mathematics of symbolic computation. The barebones but friendly nature of Lua make it a fairly ideal language from a pedagogical point of view.
\end{itemize}

\subsection{Features}
                
Currently, {\ttfamily luacas} includes the following functionality:
                
\begin{itemize}
    \item Arbitrary-precision integer and rational arithmetic
    \item Number-theoretic algorithms for factoring integers and determining primality
    \item Constructors for arbitrary polynomial rings and integer mod rings, and arithmetic algorithms for both
    \item Factoring univariate polynomials over the rationals and over finite fields
    \item Polynomial decomposition and some multivariate functionality, such as pseudodivision
    \item Basic symbolic root finding
    \item Symbolic expression manipulations such as expansion, substitution, and simplification
    \item Symbolic differentiation and integration
\end{itemize}
                
The CAS is written using object-oriented Lua, so it is modular and would be easy to extend its functionality (which we hope to do in the future).

\section{Installation}

\subsection{Requirements}

The \texttt{luacas} package (naturally) requires you to compile with Lua\LaTeX{}. Beyond that, the following packages are needed:
\begin{multicols}{2}
{\ttfamily 
\begin{itemize}
    \item xparse
    \item pgfkeys
    \item verbatim
    \item amsmath
    \item luacode
    \item iftex
    \item tikz/forest
    \item xcolor
\end{itemize}}
\end{multicols}
The packages {\ttfamily tikz, forest, xcolor} aren't strictly required, but they are needed for drawing expression trees.

\subsection{Installing {\ttfamily luacas}}
The package manager for your local TeX distribution ought to install the package fine on its own. But for those who like to take matters into their own hands: unpack \texttt{luacas.zip} in the current working directory (or in a directory visible to TeX, like your local texmf directory), and in the preamble of your document, put:
\inputminted[firstline=3,
    lastline=3,
    breaklines]
    {latex}
    {doc.tex}
That's it, you're ready to go.

\section{Tutorials}

Taking a cue from the phenomenal TikZ documentation, we introduce basic usage of the \texttt{luacas} package through a few informal tutorials.  

\subsection{Tutorial 1: Limit Definition of the Derivative}

Alice is teaching calculus, and she wants to give her students many examples of the dreaded \emph{limit definition of the derivative}. On the other hand, she'd like to avoid working out many examples by-hand. She decides to give \texttt{luacas} a try.

Alice can access the \texttt{luacas} program using a custom environment: \mintinline{latex}{\begin{CAS}..\end{CAS}}. The first thing Alice must do is declare variables that will be used going forward:
\inputminted[
    firstline=55,
    lastline=57,
    breaklines]
    {latex}
    {demo.tex}
Alice decides that $f$, the function to be differentiated, should be $x^2$. So Alice makes this assignnment with:
\inputminted[
    firstline=59,
    lastline=62,
    breaklines]
    {latex}
    {demo.tex}
Now, Alice wants to use the variable $q$ to store the appropriate \emph{difference quotient} of $f$. Alice could hardcode this into $q$, but that seems to defeat the oft sought after goal of reusable code. So Alice decides to use the \texttt{substitute} command of \texttt{luacas}:
\inputminted[
    firstline=64,
    lastline=69,
    breaklines]
    {latex}
    {demo.tex}
Alice is curious to know if $q$ is what she thinks it is. So Alice decides to have \LaTeX{} print out the contents of $q$ within her document. For this, she uses the \mintinline{latex}{\print} command. 
\begin{CAS}
    vars('x','h')
    f = x^2
    subs = {[x]=x+h}
    q = (substitute(subs,f)- f)/h
\end{CAS}
\begin{codebox}
    \inputminted[
    firstline=71,
    lastline=71,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \[ \print{q} \] 
\end{codebox}
So far so good! Alice wants to expand the numerator of $q$; she finds the aptly named \texttt{expand} method helpful in this regard. Alice redefines \mintinline{lua}{q} to be \mintinline{lua}{q=expand(q)}, and prints the result to see if things worked as expected:
\begin{codebox}
    \inputminted[
    firstline=73,
    lastline=80,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \begin{CAS}
        q = expand(q)
    \end{CAS}
    \[ \print*{q} \] 
\end{codebox}
Alice is pleasantly surprised that the result of the expansion has been \emph{autosimplified}, i.e., the factors of $x^2$ and $-x^2$ cancelled each other out, and the resulting extra factor of $h$ has been cancelled out as well.  

Finally, Alice wants to take the limit as $h\to 0$. Now that our difference quotient has been expanded and simplified (automatically), this amounts to another substitution:
\begin{codebox}
    \inputminted[
    firstline=82,
    lastline=91,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \begin{CAS}
        subs = {[h]=0}
        q = q:substitute(subs)
    \end{CAS}
    \[ \print{q} \] 
\end{codebox}
Alice is slightly disappointed that $0+2x$ is returned and not $2x$. Alice takes a guess that there's a \mintinline{lua}{simplify} command. This does the trick: adding the line \mintinline{lua}{q = simplify(q)} before leaving the \texttt{CAS} environment returns the expected $2x$:
\begin{codebox}
    \inputminted[
    firstline=93,
    lastline=103,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \begin{CAS}
        q=simplify(q)
    \end{CAS}
    \[ \print{q} \] 
\end{codebox}

Alternatively, Alice could have used the \mintinline{latex}{\print*} command instead of \mintinline{latex}{\print} -- the essential difference is that \mintinline{latex}{\print*}, unlike \mintinline{latex}{\print}, automatically simplifies the content of the argument. 

Alice is pretty happy with how everything is working, but she wants to be able to typeset the individual steps of this process. Alice is therefore thrilled to learn that the \mintinline{latex}{\begin{CAS}..\end{CAS}} environment is very robust -- it can:
\begin{itemize}
    \item Be entered into and exited out of essentially anywhere within her \LaTeX{} document, for example, within \mintinline{latex}{\begin{aligned}..\end{aligned}}; and 
    \item CAS macros persist -- if Alice assigns \mintinline{lua}{f = x^2} within \mintinline{latex}{\begin{CAS}..\end{CAS}}, then the CAS remembers that \mintinline{lua}{f = x^2} the next time Alice enters the CAS environment. 
\end{itemize}
Here's the final version of Alice's code: 
\begin{codebox}[sidebyside align=top]
    \inputminted[
    firstline=105,
    lastline=131,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \begin{CAS}
        vars('x','h')
        f = x^2
    \end{CAS}
    Let $f(x) = \print{f}$. We wish to compute the derivative of $f(x)$ at $x$ using the limit definition of the derivative. Toward that end, we start with the appopriate difference quotient:
    \begin{CAS}
        subs = {[x]=x+h}
        q = (substitute(subs,f) - f)/h
    \end{CAS}
    \[ \begin{aligned}
        \print{q} &= 
        \begin{CAS} 
            q = expand(q) 
        \end{CAS}
        \print{q}& &\text{expand/simplify} \\
        \begin{CAS}
            subs = {[h]=0}
            q = substitute(subs,q)
        \end{CAS}
        &\xrightarrow{h\to 0} \print{q}& &\text{take limit}\\ 
        &= 
        \begin{CAS}
            q = simplify(q)
        \end{CAS}
        \print{q} & &\text{simplify.}
    \end{aligned} \] 
    So $\print{diff(f,x)} = \print*{diff(f,x)}$.     
\end{codebox}
Alice can produce another example merely by changing the definition of $f$ on the third line to another polynomial:
\begin{codebox}[sidebyside align=top]
    \inputminted[
    firstline=133,
    lastline=138,
    breaklines]
    {latex}
    {demo.tex}
    \tcblower
    \begin{CAS}
        vars('x','h')
        f = 2*x^3-x
    \end{CAS}
    Let $f(x) = \print{f}$. We wish to compute the derivative of $f(x)$ at $x$ using the limit definition of the derivative. Toward that end, we start with the appopriate difference quotient:
    \begin{CAS}
        subs = {[x] = x+h}
        q = (f:substitute(subs) - f)/h
    \end{CAS}
    \[ \begin{aligned}
        \print{q} &= 
        \begin{CAS} 
            q = expand(q)
        \end{CAS}
        \print{q}& &\text{expand/simplify} \\
        \begin{CAS}
            subs = {[h]=0}
            q = q:substitute(subs)
        \end{CAS}
        &\xrightarrow{h\to 0} \print{q}& &\text{take limit} \\ 
        &= 
        \begin{CAS}
            q = simplify(q)
        \end{CAS}
        \print{q}& &\text{simplify.}
    \end{aligned} \] 
    So $\print{diff(f,x)} = \print*{diff(f,x)}$.     
\end{codebox}

\subsection{Tutorial 2: Finding maxima/minima}

Bob is teaching calculus too, and he wants to give his students many examples of \emph{finding the local max/min of a given function}. But, like Alice, Bob doesn't want to work out a bunch of examples by-hand. Bob decides to try his hand with \texttt{luacas} after having been taught the basics by Alice. 

Bob decides to stick with polynomials for these examples; if anything because those functions are in the wheel-house of \texttt{luacas}.


\subsection{Advanced}



\appendix

\section{The \LaTeX{} code}

As noted above, this package is really a Lua program; the package {\ttfamily luacas.sty} is merely a shell to make accessing that Lua program easy and manageable from within \LaTeX{}. 
\inputminted[
    firstline=12,
    lastline=14,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}

We check to make sure the user is compiling with Lua\LaTeX{}; if not, an error message is printed and compilation is aborted. 

\inputminted[
    firstline=16,
    lastline=24,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}

The following pacakages are required for various macros:

\inputminted[
    firstline=27,
    lastline=32,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}

The files \verb|helper.lua| and \verb|parser.lua| help bridge the gap between the Lua program and \LaTeX{}. 

\inputminted[
    firstline=35,
    lastline=37,
    breaklines,
    linenos,
    numbersep=5pt]
    {latex}
    {luacas.sty}
    
\section{Lua Documentation}

This section is geared towards those who are interested in the inner workings of the Lua end of the CAS. In particular, anyone who wishes to modify or expand the CAS for their own purposes should read this.
 
This section also assumes some familiarity with the programming language Lua, including using prototypes for object-oriented programning in Lua. For a comprehensive introduction to Lua, we refer the reader to \cite{pil}. Chapter 16 of \cite{pil} provides a good introduction to object-oriented design and inheritance in Lua. 
 
 \subsection{Class Structure and Inheritance}
 
Every object in the CAS is an expression, meaning it inherits from the {\ttfamily Expression} type (class). Since the {\ttfamily Expression} type itself has no constructor and cannot be instantiated, it it closer to an interface in Java OOP terms.\footnote{In reality, interfaces are unnecessary in Lua due to its weak typing - Lua doesn't check whether an object has a method at compile time. The {\ttfamily Expression} type is really an abstract class in Java terms, but we will call it an interface for simplicity.} {\ttfamily Expression}s can store any number of other expressions as sub-expressions, depending on type. This means that {\ttfamily Expression} objects are really trees. Types that inherit from {\ttfamily Expression} that can not store other expressions are called \emph{atomic expressions}, and correspond to the leaf nodes of the tree. Other expression types are \emph{compound expressions}. Thus, every {\ttfamily Expression} type inherits from one of {\ttfamily AtomicExpression} or {\ttfamily CompoundExpression}. The {\ttfamily ConstantExpresssion} interface is a subinterface to {\ttfamily AtomicExpression}.\footnote{See the Section B.2. {\ttfamily isconstant()} entry for details.} Types that inherit from {\ttfamily ConstantExpression} roughly correspond to numbers. An outline of the inheritance hierarchy is pictured below:

\begin{figure}[h]
\centering

\begin{tikzpicture}[interface/.style={rectangle, draw=orange!60, fill=orange!5, very thick, minimum size=5mm},class/.style={text width=2.5cm,rectangle, draw=blue!60, fill=blue!5, very thick, minimum size=5mm}]

\node[interface] at (0, 0) (exp) {\ttfamily Expression};
\node[interface] at (-2, -2) (atom) {\ttfamily AtomicExpression};
\node[interface] at (2, -2) (comp) {\ttfamily CompoundExpression};
\node[interface] at (-6, -4) (constant) {\ttfamily ConstantExpression};

\node[class] (num) [below=of constant] {Integers, Rationals};

\node[class] at (-2, -4) (sym) [below=of atom] {Symbols, Polynomials};

\node[class] at (2, -4) (sum) [below=of comp] {Sums, Products, \newline Integrals, Sets, Vectors, Matrices};

\draw[->] (atom.north) -- (exp.south);
\draw[->] (comp.north) -- (exp.south);
\draw[->] (constant.north) -- (atom.south);

\draw[->] (num.north) -- (constant.south);
\draw[->] (sym.north) -- (atom.south);
\draw[->] (sum.north) -- (comp.south);

\end{tikzpicture}

\caption{Interfaces in the Lua\LaTeX{} CAS and examples of types that inherit from each interface.}

\end{figure}

Most operations that a user would want to apply to expressions, such as derivatives and integrals, are encapsulated into their own types. These types have the {\ttfamily Expression}s that these operations are applied to as instance variables, and thus are compound expressions. The other kind of operations on expressions are \emph{core methods}, which are methods in the objected-oriented sense, and can be called on expressions using the {\ttfamily :} syntax as is typical in Lua. The rule of thumb is that if there is standard mathematical notation for an operation or function represented by the CAS, it gets its own class, and if not, it is a core method. This way, every Lua expression corresponds to something that can be cleanly displayed in \LaTeX{}. This also gives us a compact way to display expression trees in this guide, namely, using mathematical notation.


\subsubsection{Metamethod inheritance}
This CAS takes advantage of Lua's metamethods, particularly the mathematical operators, to reduce the notational burden of expression construction. Unlike regular methods, metamethods cannot be inherited - if two tables don't have a {\ttfamily \_\_add} metamethod, it won't trigger the table's {\ttfamily \_\_index} metamethod. This means that all such metamethods are created in their own tables with names that start with a double underscore, such as {\ttfamily \_\_RingOperations}, and assigned to the correct object in its constructor method.


\subsection{Core Methods}

All of the following core methods can be applied to any expression, and are defined in the {\ttfamily expression.lua} interface.

\begin{itemize}
    \item {\ttfamily evaluate()} applies an expression that represents an operation on expressions to its subexpressions. For instance, evaluating a {\ttfamily DerrivativeExpression} applies the derivative operator with respect to the {\ttfamily symbol} field to its {\ttfamily expression} field. Evaluating a {\ttfamily BinaryOperation} with its {\ttfamily operation} field set to {\ttfamily ADD} returns the sum of the numbers in the {\ttfamily expressions} field, if all of the expressions are numbers. If the expression does not represent an operation or is unable to be evaluated, calling {\ttfamily evaluate()} on an expression returns itself.
    
    \item {\ttfamily autosimplify()} performs fast simplification techniques on an expression. All input from the \LaTeX{} end and everything output to the \LaTeX{} end is autosimplified. Generally, one should call {\ttfamily autosimplify()} on expressions before applying other core methods to them. The {\ttfamily autosimplify()} method also calls the {\ttfamily evaluate()} method.
    
    \item {\ttfamily simplify()} performs full simplification of an expression. This may involve polynomial factorization, which is slow, so this is seperate from autosimplification and not called on the \LaTeX{} end unless the user specifically directs the CAS to simplify.
    
    \item {\ttfamily subexpressions()} returns a list of all subexpressions of an expression. This gives a unified interface to the instance variables for subexpressions, which have different names across classes.
    
    \item {\ttfamily size()} returns the number of nodes of the tree that constitutes an expression, or roughly the total number of expression objects that make up the expression.
    
    \item {\ttfamily setsubexpressions(subexpressions)} creates a copy of an expression with the list of subexpressions as its new subexpressions. This can reduce code duplication in other methods.
    
    \item {\ttfamily freeof(symbol)} determines whether or not an expression contains a particular \\ {\ttfamily SymbolExpression} somewhere in the tree.
    
    \item {\ttfamily substitute(map)} takes a table mapping expressions to other expressions and recursively maps each instance of an expression with its corresponding table expression.
    
    \item {\ttfamily expand()} expands an expression, turning sums of products into products of sums.
    
    \item {\ttfamily factor()} factors an expression, turning products of sums into sums of products.
    
    \item {\ttfamily isatomic()} determines whether an expression is \emph{atomic}, i.e., whether it has any subexpression fields. Otherwise, an expression is \emph{compound}. Atomic expressions and compound expressions are both sub-interfaces to expressions, and all classes inherit from one of those interfaces.
    
    \item {\ttfamily isconstant()} determines whether an expression is atomic and contains no variables. This method is counterintuitive in some cases, for instance, it returns {\ttfamily false} for the constant $\pi$. This is because {\ttfamily isconstant()} is meant to check for certain autosimplification  transformations that can be performed on arbitrary {\ttfamily Ring} elements but not on those constants. Use {\ttfamily isrealconstant()} for what mathematicians think of as constants.
    
    \item {\ttfamily isrealconstant()} determines whether an expression is a real number in the mathematical sense, such as $2$, $\sqrt{5}$, or $\sin(3)$.
    
    \item {\ttfamily iscomplexconstant()} determines whether an expression is a complex number in the mathematical sense, such as $3 + \sqrt{2}i$.
    
    \item {\ttfamily tolatex()} converts an expression to \LaTeX{} code.
\end{itemize}

The number of core methods should generally be kept small, since every new type of expression must implement all of these methods. The exception to this, of course, is core methods that call other core methods that provide a unified interface to expressions. For instance, {\ttfamily size()} calls {\ttfamily subexpressions()}, so it only needs to be implemented in the expression interface.

All expressions should also implement the {\ttfamily \_\_tostring} and {\ttfamily \_\_eq} metamethods. As mentioned previously, metamethods cannot be inherited using Lua, thus every expression object created by a constructor must assign a metatable to that object.

\begin{itemize}
    \item {\ttfamily \_\_tostring} provides a human-readable version of an expression for printing within Lua. Used for debugging purposes.
    
    \item {\ttfamily \_\_eq} determines whether an expression is structurally identical to another expression.
\end{itemize}

\subsection{Algebra Package}

The algebra package contains functionality for arbitrary-precision arithmetic, polynomial arithmetic and factoring, symbolic root finding, and logarithm and trigonometric expression classes. It requires the core package to be loaded.

\subsubsection{Ring Interfaces}

Most classes in the algebra package inherit from the {\ttfamily Ring} interface, which itself inherits from the \\ {\ttfamily ConstantExpression} interface. The {\ttfamily Ring} interface requires the following arithmetic operations, which have corresponding metamethods listed below. For ring objects {\ttfamily a} and {\ttfamily b},

\begin{itemize}
    \item {\ttfamily a:add(b) (a + b)} adds two ring elements.
    \item {\ttfamily a:sub(b) (a - b)} subtracts one ring element from another. Subtraction has a default implementation in {\ttfamily Ring.lua} as adding the additive inverse, but this can be overwritten if a faster performance method is available.
    \item {\ttfamily a:neg() (-a)} returns the additive inverse of a ring element.
    \item {\ttfamily a:mul(b) (a * b)} multiplies two ring elements.
    \item {\ttfamily a:pow(n) (a \wedge{} n)} raises one ring element to the power of an integer. Exponentiation has a default implementation as repeated multiplication, but this can (and probably should) be overwritten for faster performance.
    \item {\ttfamily a:eq(b) (a == b)} tests if two ring elements are the same.
    \item {\ttfamily a:lt(b) (a < b)} tests if one ring element is less than another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item {\ttfamily a:le(b) (a <= b)} tests if one ring element is less than or equal to another under some total order. If the ring does not have a natural total order, this method does not need to be implemented.
    \item {\ttfamily a:zero()} returns the additive identity of a ring.
    \item {\ttfamily a:one()} returns the multiplicative identity of a ring.
\end{itemize}

The arithmetic methods should only be used with two objects of the same type, while the metamethods can be used on objects of potentially different types, since they handle conversion between different types of rings. \footnote{See section B.3.2 for details.}

The {\ttfamily EuclideanDomain} interface is a subinterface to the Ring interface, which also requires the following operations:

\begin{itemize}
    \item {\ttfamily a:divremainder(b) (a // b) (a \% b)} returns both the result of Eulcidean division and the remainder when a is divided by b.
\end{itemize}

The {\ttfamily Field} interface is a subinterface to the {\ttfamily EuclideanDomain} interface, which also requires the following operations:

\begin{itemize}
    \item {\ttfamily a:div(b) (a / b)} divides one ring element by another. Division has a default implementation as multiplying by the multiplicative inverse, but this can be overwritten if a faster performance method is available.
     \item {\ttfamily a:inv()} returns the multiplicative inverse of a ring element.
\end{itemize}


\subsubsection{Ring Conversion}

Many of the rings in the algebra package are subsets of one another. For instance, integers are subsets of rationals, which are subsets of polynomial rings over the rationals, etc. To smoothly convert objects from one ring to another, the {\ttfamily RingIdentifier} object acts as a pseudo-class that stores information the exact ring of an object, including the symbol the ring has if it's a polynomial ring, for instance. To perform operations on two elements of different rings, the CAS does the following: 

To get the generic {\ttfamily RingIdentifier} from a class, it uses the static {\ttfamily Ring.makering()} method. To get the {\ttfamily RingIdentifier} from a specific instance (element) of a ring, it uses the {\ttfamily :getring()} method. From there, the CAS computes the smallest {\ttfamily RingIdentifier} that contains the two {\ttfamily RingIdentifier}s as subsets using the static {\ttfamily Ring.resultantring()}. Finally, the CAS converts both objects into the resultant {\ttfamily RingIdentifier} using the {\ttfamily :inring(ring)} method if possible, and then performs the operation.

To add another class that implements {\ttfamily Ring} and has proper conversion abilities, the {\ttfamily resultantring} method needs to be updated to include all possible resultant rings constructed from the new ring and existing rings. The other three methods need to be implemented as well.

\subsubsection{Types}

The following types do not inherit from the {\ttfamily Ring} interface, instead inheriting from the {\ttfamily CompoundExpression} interface.

\begin{itemize}
    \item {\ttfamily AbsExpression(expression)} creates a new expression corresponding to the absolute value of \\ {\ttfamily expression}.
    \item {\ttfamily Logarithm(base, expression)} creates a new expression corresponding to the logarithm base {\ttfamily base} of {\ttfamily expression}.
    \item {\ttfamily SqrtExpression(expression, root)} creates a new expression corresponding the the {\ttfamily root}th root of {\ttfamily expression}. If {\ttfamily root} is omitted, it defaults to $2$.
    \item {\ttfamily TrigExpression(name, expression)} creates a new expression corresponding to a trigonometric function applied to {\ttfamily expression}. The valid names are $\sin$, $\cos$, $\tan$, $\csc$, $\sec$, $\cot$, $\arcsin$, $\arccos$, $\arctan$, arccsc, arcsec, and arccot.
    
    \item {\ttfamily RootExpression(expression)} creates an expression that represents the solutions to {\ttfamily expression} $= 0$ when they would be unwieldy or impossible to display using standard algebraic functions.
\end{itemize}


The following types inherit from the {\ttfamily Ring} interface. However, not all of them are proper {\ttfamily ConstantExpression}s, so some of them override the {\ttfamily isconstant()} method.

\begin{itemize}
    \item {\ttfamily Integer(n)} takes a string, number, or {\ttfamily Integer} input and constructs an Integer. Since Lua can only store integers exactly up to a certain point, it is recommended to use strings to build large integers.
    \item {\ttfamily IntegerModN(i, n)} takes an {\ttfamily Integer i} and {\ttfamily Integer n} and constructs an integer in the ring $\mathbb{Z_n}$. 
    \item {\ttfamily Rational(n, d, keep)} takes a numerator {\ttfamily n} and denominator {\ttfamily d} in the same ring and constructs a rational expression in the field of fractions over that ring. For the integers, this is the ring of rational numbers. If the {\ttfamily keep} flag is omitted, the constructed object will be simplified to have smallest possible denominator, possibly returning an object in the original ring {\ttfamily n} and {\ttfamily d} where in.
    \item {\ttfamily PolynomialRing(coefficients, symbol, degree)} takes a list of {\ttfamily coefficients} not necessarily in the same ring and a {\ttfamily SymbolExpression symbol} to create a polynomial in the polynomial ring with the given {\ttfamily symbol} and coefficients in the smallest possible ring that includes all of the coefficients. If {\ttfamily degree} is omitted, it will calculate the degree of the polynomial automatically. The list can either be one-indexed or zero-indexed, but if it is one-indexed, the internal list of coefficients will still be zero-indexed.
\end{itemize}

\subsection{Calculus Package}

The calculus package contains expression types for integration and differentiation. It requires both the algebra and core packages to be loaded.

\subsubsection{Types}
All types added by the calculus package inherit from the {\ttfamily CompoundExpression} interface.

\begin{itemize}
    \item {\ttfamily DerivativeExpression(expression, symbol)} creates a new derivative expression, representing the single-variable derivative of {\ttfamily expression} with respect to {\ttfamily symbol}. If {\ttfamily symbol} is omitted, it defaults to $x$.
    
    \item {\ttfamily DiffExpression(expression, symbols)} creates a new differential expression, representing the multi-variable derivative of {\ttfamily expression} with respect to each symbol in the list {\ttfamily symbol}.
    
    \item {\ttfamily IntegralExpression(expression, symbol, lower, upper)} creates a new indefinite integral expression, representing the integral of {\ttfamily expression} with respect to {\ttfamily symbol} from {\ttfamily lower} to {\ttfamily upper} If both {\ttfamily lower} and {\ttfamily upper} are omitted, creates a new indefinite integral expression instead.
\end{itemize}

\subsection{Constructing Expressions \& Basic Parsing}

Algebraic computations on the Lua end typically involve constructing the desired expression and applying one or more core operations to the expression. If a non-core operation is applied, then this core expression will be {\ttfamily autosimplify()}.

Naively, one could nest class constructors to build an expression. For instance, the Lua code for evaluating the integral \[ \int_0^6 \sin(x) + 2x^2 + 3 \hspace{2pt}\mathrm{d}x\] and storing the result in a variable {\ttfamily r} is as follows:

\begin{minted}{lua}
r = IntegralExpression(BinaryOperation(BinaryOperation.ADD,
            {TrigExpression("sin", SymbolExpression("x")),
            BinaryOperation(BinaryOperation.MUL,
                {Integer(2),
                BinaryOperation(BinaryOperation.POW,
                {SymbolExpression("x"), Integer(2)})}),
            Integer(3)}),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

This is more than unwieldy, so a number of constructs are added to make using and developing the CAS easier. Metatables for many binary operations allow natural symbols to act as constructors that use Lua's build-in operator precedence:

\begin{minted}{lua}
r = IntegralExpression(TrigExpression("sin", SymbolExpression("x")) +
        Integer(2) * SymbolExpression("x") ^ Integer(2) +
        Integer(3),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

Several functions are added as shorthand for constructors that mirror familiar syntax. These function names are in all caps to reduce the risk of collisions.

\begin{minted}{lua}
r = INT(SIN(SymbolExpression("x")) + Integer(2) * SymbolExpression("x") ^ Integer(2) 
    + Integer(3),
        SymbolExpression("x"),
        Integer(0),
        Integer(6)):autosimplify()
\end{minted}

This is still fairly unwieldy, mostly because every string and number need to be wrapped in a constructor to convert them to expressions. Unfortunately, this syntax is also the most awkward to avoid in Lua, and the inner workings of the code just uses the longer constructors.

For \LaTeX{} users, or for Lua users who are looking for a simpler paradigm, a parser was implemented that takes the code input as a string and wraps numbers in the {\ttfamily Integer} constructor, then evaluates the code using Lua's {\ttfamily load()} function. The {\ttfamily vars()} command also allows variables to be declared as symbol expressions with the same name, at the cost of being able to use these symbols to reference other objects. Using the parser, the code now looks like:

\begin{minted}{lua}
CASparse([[
    vars("x")
    r = int(sin(x) + 2*x^2 + 3, x, 0, 6)
]])
\end{minted}

\newpage

\printbibliography


\end{document}