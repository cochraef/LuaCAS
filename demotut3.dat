%% LaTeX2e file `demotut3.dat'
%% generated by the `filecontents' environment
%% from source `tut3' on 2022/08/17.
%%
\documentclass{article}
\usepackage{multicol,fullpage,luacas,parskip,asypictureB,minted}

\usepackage{pgfplots,forest,eso-pic}
\usetikzlibrary{calc}

\begin{document}

\begin{CAS}
    vars('x','h')
    f = 1/(x^2+1)
    subs = {[x]=x+h}
    q = (substitute(subs,f)-f)/h
    q = expand(q)
\end{CAS}

\parseforest{q}
\bracketset{action character = @}
\begin{forest}
    for tree = {
        font=\ttfamily,
        rectangle,
        rounded corners=1pt
    },
    where level=0{%
        fill=orange!25
    }{},
    @\forestresult
\end{forest}

\begin{CAS}
    r = diff(q,x,h)
\end{CAS}
\whatis{q} vs \whatis{r}

\luaexec{if q.operation == BinaryOperation.ADD then
    tex.print("I'm an \\texttt{ADD}")
end}

\luaexec{tex.print("I'm an order", r.degree, "derivative.")}

\parseshrub{q}
\begin{forest}
    for tree = {draw,rectangle,rounded corners=1pt,fill=lightgray!20,font=\ttfamily}
    @\shrubresult
\end{forest}

\parseshrub{q.expressions[1]}
\begin{forest}
    for tree = {draw,rectangle,
    rounded corners=1pt,fill=lightgray!20,
    font=\ttfamily, s sep=2cm}
    @\shrubresult
\end{forest}

\parseshrub{r}
\begin{forest}
    for tree = {draw,rectangle,
    rounded corners=1pt,fill=lightgray!20,
    font=\ttfamily, s sep=1cm}
    @\shrubresult
\end{forest}

\newpage

Now that Charlie knows the basics of how \texttt{luacas} is structured, they're ready to write their own function \texttt{combine} that will take a sum of rational expressions and form an equivalent singular rational expression under a common denominator. Charlie will need to know a little Lua, but nothing too far beyond the typical \texttt{if-then} logical operators.

It's best if Charlie writes this Lua function in a separate file, say \texttt{myfunction.lua}. We walk through Charlie's design below, and like many functions in \texttt{luacas}, he defines this function as a method:

\begin{minted}[breaklines,linenos]{lua}
function Expression:combine()
    local den, num, aux, mul, input = {}, {}, {}, {}, self:autosimplify():expand()
    if input.operation ~= BinaryOperation.ADD then
        return input
    end
\end{minted}

First, Charlie checks if the input, renamed and simplified from \mintinline{lua}{self} to \mintinline{lua}{input}, is in fact a \texttt{BinaryOperation} with operation equal to \texttt{ADD}. If not, then \texttt{input} is returned.

\begin{minted}[breaklines,linenos,firstnumber=6]{lua}
    for _, expr in ipairs(input.expressions) do
\end{minted}

Next, Charlie starts to march through the expressions \texttt{expr} of \texttt{result} stored in \texttt{result.expressions}.

\begin{minted}[breaklines,linenos,firstnumber=7]{lua}
        local numpart, denpart = Integer.one(), Integer.one()
            if expr.operation == BinaryOperation.POW and expr.expressions[2] == -Integer.one() then
\end{minted}
The first thing Charlie checks is if the current \texttt{expr} is a \texttt{BinaryOperation} with operation \texttt{POW}. If so, then Charlie checks to see if the second expression in \texttt{expr} is equal to $-1$ (if \texttt{expr} is a \texttt{POW}, then the exponent is stored in \texttt{expr.expressions[2]}). If so, then this means that \texttt{expr.expressions[1]} is a denominator-term.

\begin{minted}[breaklines,linenos,firstnumber=9]{lua}
                denpart = denpart*expr.expressions[1]
                for _,term in ipairs(den) do
                    if expr.expressions[1] == term then
                        goto continue
                    end
                end
                table.insert(den,expr.expressions[1])
                ::continue::
            end
\end{minted}

In this case, Charlie makes \texttt{expr.expressions[1]} a factor of the local variable \texttt{denpart} (for \emph{denominator part}). Charlie then scans the contents of the table \texttt{den} to see if \texttt{expr.expressions[1]} has already been included. If it hasn't, then Charlie includes it into the table with \texttt{table.insert}. The table \texttt{den} will eventually contain all terms that comprise the common denominator. Of course, \texttt{expr} may not be a \texttt{POW}...

\begin{minted}[linenos,breaklines,firstnumber=18]{lua}
        if expr.operation == BinaryOperation.MUL then
            for _,subexpr in ipairs(expr.expressions) do
                if subexpr.operation == BinaryOperation.POW and subexpr.expressions[2] == -Integer.one() then
                    denpart = denpart*subexpr.expressions[1]
                    for _,term in ipairs(den) do
                        if subexpr.expressions[1] == term then
                            goto continue
                        end
                    end
                    table.insert(den,subexpr.expressions[1])
                    ::continue::
                else
                    numpart = numpart*subexpr
                end
            end
        end
        if not (expr.operation == BinaryOperation.POW or expr.operation == BinaryOperation.MUL) then
            numpart = expr
        end
        table.insert(num,numpart)
        table.insert(aux,denpart)
    end
\end{minted}
In particular, it could be that \texttt{expr} is a \texttt{MUL}, or  neither a \texttt{POW} nor a \texttt{MUL}. So Charlie must reckon with these possibilities as well. But in all cases, Charlie marches through the (sub)expressions, recording denominators and numerators as they go. In the end, Charlie has:
\begin{itemize}
    \item \texttt{den}, a table whose product of terms gives us the common denominator we seek;
    \item \texttt{num}, a table whose terms are the numerators of the subexpressions of the parent \texttt{ADD} expression;
    \item \texttt{aux}, a table whose terms are the denominators of the subexpressions of the parent \texttt{ADD} expression.
\end{itemize}
Charlie now forms the \texttt{denominator} of the final output.
\begin{minted}[breaklines,linenos,firstnumber=40]{lua}
    local denominator = Integer.one()
    local numerator   = Integer.zero()
    for _,expr in ipairs(den) do
        denominator = denominator*expr
    end
    denominator = denominator:autosimplify()
\end{minted}
Charlie now forms the \texttt{numerator} of the final output.
\begin{minted}[breaklines,linenos,firstnumber=46]{lua}
    for index,expr in ipairs(num) do
        local uncommon = denominator/aux[index]
        uncommon = uncommon:factor():simplify()
        numerator = numerator + expr*uncommon
    end
    numerator = numerator:simplify()
\end{minted}
Finally, Charlie returns the final result:
\begin{minted}[breaklines,linenos,firstnumber=52]{lua}
    return numerator/denominator
end
\end{minted}
Charlie may now use the \texttt{:combine()} method within \mintinline{latex}{\begin{CAS}..\end{CAS}}.

\newpage

\luaexec{
function BinaryOperation:combine()
    local den, num, aux, mul, input = {}, {}, {}, {}, self:autosimplify():expand()
    if input.operation ~= BinaryOperation.ADD then
        return input
    end
    for _, expr in ipairs(input.expressions) do
        local numpart, denpart = Integer.one(), Integer.one()
        if expr.operation == BinaryOperation.POW and expr.expressions[2]:type() == Integer and expr.expressions[2] < Integer.zero() then
            denpart = denpart*expr.expressions[1] ^ expr.expressions[2]:neg()
            for index,term in ipairs(den) do
                if expr.expressions[1] == den[index] then
                    if expr.expressions[2]:neg() > mul[index] then
                        mul[index] = expr.expressions[2]:neg()
                        goto continue
                    else
                        goto continue
                    end
                end
            end
            table.insert(den,expr.expressions[1])
            table.insert(mul,expr.expressions[2]:neg())
            ::continue::
        end
        if expr.operation == BinaryOperation.MUL then
            for _,subexpr in ipairs(expr.expressions) do
                if subexpr.operation == BinaryOperation.POW and subexpr.expressions[2]:type() == Integer and subexpr.expressions[2] < Integer.zero() then
                    denpart = denpart*subexpr.expressions[1] ^ subexpr.expressions[2]:neg()
                    for index,term in ipairs(den) do
                        if subexpr.expressions[1] == den[index] then
                            if subexpr.expressions[2]:neg() > mul[index] then
                                mul[index] = subexpr.expressions[2]:neg()
                                goto continue
                            else
                                goto continue
                            end
                        end
                    end
                    table.insert(den,subexpr.expressions[1])
                    table.insert(mul,subexpr.expressions[2]:neg())
                    ::continue::
                else
                    numpart = numpart*subexpr
                end
            end
        end
        if expr.operation ~= BinaryOperation.POW and expr.operation ~= BinaryOperation.MUL then
            numpart = expr
        end
        table.insert(num,numpart)
        table.insert(aux,denpart)
    end
    local denominator = Integer.one()
    local numerator   = Integer.zero()
    for index,expr in ipairs(den) do
        denominator = denominator*den[index] ^ mul[index]
    end
    denominator = denominator:autosimplify()
    for index,expr in ipairs(num) do
        local uncommon = denominator/aux[index]
        uncommon = uncommon:factor():simplify()
        numerator = numerator + expr*uncommon
    end
    numerator = numerator:simplify():factor()
    return numerator/denominator
end
}

\begin{CAS}
    vars('x','y','z')
    a = y/z
    b = z/x
    c = x/y
    d = a+b+c
    d = d:combine()
\end{CAS}
\[ \print{d} \]

\begin{CAS}
    vars('x','h')
    f = x/(x^2+1)
    subs = {[x]=x+h}
    q = (substitute(subs,f)-f)/h
    q = q:combine()
\end{CAS}
\[ \print{q} \]

\end{document}
